<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Student Canvas</title>
  <style>
    :root {
      color-scheme: light dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #e2f3ff 0%, #f1f5f9 45%, #e2e8f0 100%);
      padding: 24px;
      color: #0f172a;
    }

    .shell {
      width: min(960px, 100%);
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(18px);
      border-radius: 24px;
      box-shadow: 0 35px 60px rgba(15, 23, 42, 0.18);
      padding: clamp(20px, 3vw, 32px);
      display: flex;
      flex-direction: column;
      gap: clamp(20px, 3vw, 28px);
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.4rem, 2.4vw, 1.9rem);
      font-weight: 700;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 600;
      border: 1px solid rgba(15, 118, 110, 0.2);
      background: rgba(16, 185, 129, 0.1);
      color: #0f766e;
    }

    .status[data-state="connecting"] {
      border-color: rgba(37, 99, 235, 0.2);
      background: rgba(37, 99, 235, 0.12);
      color: #1d4ed8;
    }

    .status[data-state="error"] {
      border-color: rgba(220, 38, 38, 0.2);
      background: rgba(248, 113, 113, 0.12);
      color: #b91c1c;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .group {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(226, 232, 240, 0.6);
      border-radius: 16px;
      padding: 8px 12px;
    }

    .colors {
      display: inline-flex;
      gap: 8px;
    }

    .color-swatch {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 2px solid rgba(15, 23, 42, 0.08);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .color-swatch.is-active {
      transform: scale(1.12);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.35);
    }

    button.action-btn {
      appearance: none;
      border: 1px solid rgba(148, 163, 184, 0.7);
      border-radius: 14px;
      padding: 8px 16px;
      font-size: 0.95rem;
      font-weight: 600;
      background: linear-gradient(135deg, #ffffff 0%, #e2e8f0 100%);
      color: #0f172a;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button.action-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.action-btn:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 20px rgba(59, 130, 246, 0.18);
    }

    .slider {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }

    input[type="range"] {
      accent-color: #2563eb;
    }

    .canvas-shell {
      border-radius: 20px;
      border: 1px solid rgba(100, 116, 139, 0.2);
      background: radial-gradient(circle at top, #0f172a 0%, #1e293b 65%, #111827 100%);
      padding: clamp(12px, 2.5vw, 20px);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.18);
    }

    .canvas-frame {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      max-height: min(70vh, 620px);
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      width: 100%;
      height: 100%;
      background: #ffffff;
      border-radius: 16px;
      touch-action: none;
      cursor: crosshair;
    }

    .session {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(15, 23, 42, 0.7);
      text-align: right;
      font-weight: 600;
    }

    @media (max-width: 640px) {
      .group {
        width: 100%;
        justify-content: space-between;
      }

      .colors {
        justify-content: space-between;
        width: 100%;
      }

      .toolbar {
        align-items: stretch;
      }

      .session {
        text-align: left;
      }
    }
  </style>
</head>
<body data-role="Student">
  <main class="shell">
    <header>
      <div>
        <h1 id="pageTitle">Student Canvas</h1>
        <p id="pageSubtitle" style="margin:6px 0 0; font-size:0.95rem; color:rgba(15,23,42,0.7);">
          Draw in real-time with anyone connected to this session.
        </p>
      </div>
      <span class="status" id="connectionStatus" data-state="connecting">Connecting…</span>
    </header>

    <section class="toolbar" aria-label="Drawing controls">
      <div class="group" id="colorGroup" aria-label="Colors">
        <span style="font-size:0.85rem; font-weight:600; color:rgba(15,23,42,0.7);">Colours</span>
        <div class="colors" id="colorPalette"></div>
      </div>

      <div class="group slider" aria-label="Brush size">
        <label for="brushSize">Brush</label>
        <input id="brushSize" type="range" min="1" max="18" step="0.5" value="4" />
        <span id="brushValue">4 px</span>
      </div>

      <div class="group" aria-label="History controls">
        <button class="action-btn" id="undoBtn" type="button" disabled>Undo</button>
        <button class="action-btn" id="redoBtn" type="button" disabled>Redo</button>
        <button class="action-btn" id="clearBtn" type="button" disabled>Clear</button>
      </div>
    </section>

    <section class="canvas-shell">
      <div class="canvas-frame">
        <canvas id="board" width="800" height="600" aria-label="Drawing canvas (800 by 600)"></canvas>
      </div>
    </section>

    <p class="session">Session ID: <strong>TEST123</strong></p>
  </main>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.0/+esm';

    const SUPABASE_URL = 'https://eytswszeopdxmtxxbkrb.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5dHN3c3plb3BkeG10eHhiK3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1NTI5ODQsImV4cCI6MjA3NDEyODk4NH0.7skddGtrUoXluvK9JDS54bpmKCxVYeofzWATmJIgABE';
    const ROOM_ID = 'TEST123';

    const role = document.body.dataset.role || 'Canvas';
    const palette = {
      Canvas: ['#0f172a', '#2563eb', '#16a34a', '#ef4444'],
      Student: ['#111827', '#1d4ed8', '#16a34a', '#f97316'],
      Teacher: ['#dc2626', '#9333ea', '#0ea5e9', '#0f172a'],
    };

    const roleTitle = {
      Canvas: 'Shared Canvas',
      Student: 'Student Canvas',
      Teacher: 'Teacher Canvas',
    };

    const title = roleTitle[role] || roleTitle.Canvas;
    document.getElementById('pageTitle').textContent = title;
    document.title = `${title} – Live Drawing`;

    if (role === 'Student') {
      document.getElementById('pageSubtitle').textContent = 'Share your drawing with the teacher in real-time.';
    } else if (role === 'Teacher') {
      document.getElementById('pageSubtitle').textContent = 'Watch the shared canvas update instantly and annotate if needed.';
    }

    const colorPalette = document.getElementById('colorPalette');
    const colors = palette[role] || palette.Canvas;
    let currentColor = colors[0];

    colors.forEach((color, index) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'color-swatch';
      btn.style.background = color;
      btn.dataset.color = color;
      if (index === 0) {
        btn.classList.add('is-active');
      }
      btn.addEventListener('click', () => {
        currentColor = color;
        [...colorPalette.children].forEach((child) => child.classList.remove('is-active'));
        btn.classList.add('is-active');
      });
      colorPalette.appendChild(btn);
    });

    const brushInput = document.getElementById('brushSize');
    const brushValue = document.getElementById('brushValue');
    let brushSize = Number(brushInput.value);

    brushInput.addEventListener('input', () => {
      brushSize = Number(brushInput.value);
      brushValue.textContent = `${brushSize.toFixed(1)} px`;
    });

    brushValue.textContent = `${brushSize.toFixed(1)} px`;

    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const connectionStatus = document.getElementById('connectionStatus');

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const strokes = [];
    const strokeMap = new Map();
    const undoneStack = [];
    let currentStroke = null;
    let isDrawing = false;
    let activePointerId = null;

    const clientId = typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : `client-${Math.random().toString(36).slice(2)}`;
    const userId = `${role.toLowerCase()}-${clientId}`;

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: { persistSession: false },
    });

    const channel = supabase.channel(`room:${ROOM_ID}`, {
      config: {
        broadcast: { ack: true },
      },
    });

    function setStatus(text, state) {
      connectionStatus.textContent = text;
      if (state) {
        connectionStatus.dataset.state = state;
      }
    }

    function getPoint(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY,
      };
    }

    function drawStroke(stroke) {
      if (!stroke || !stroke.points || stroke.points.length === 0) return;
      const pts = stroke.points;
      ctx.save();
      ctx.lineWidth = stroke.size;
      ctx.strokeStyle = stroke.color;
      ctx.beginPath();
      if (pts.length === 1) {
        ctx.fillStyle = stroke.color;
        ctx.arc(pts[0].x, pts[0].y, stroke.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        return;
      }
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i += 1) {
        const point = pts[i];
        ctx.lineTo(point.x, point.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const ordered = [...strokes].sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      ordered.forEach((stroke) => drawStroke(stroke));
      if (currentStroke) {
        drawStroke(currentStroke);
      }
    }

    function updateButtons() {
      const hasLocalStrokes = strokes.some((stroke) => stroke.userId === userId);
      undoBtn.disabled = !hasLocalStrokes;
      clearBtn.disabled = !hasLocalStrokes;
      redoBtn.disabled = undoneStack.length === 0;
    }

    function addStroke(stroke, { broadcast } = { broadcast: false }) {
      if (!stroke || !stroke.id || strokeMap.has(stroke.id)) return;
      strokeMap.set(stroke.id, stroke);
      strokes.push(stroke);
      redraw();
      updateButtons();
      if (broadcast) {
        channel
          .send({
            type: 'broadcast',
            event: 'stroke',
            payload: { stroke, userId, clientId },
          })
          .catch((error) => console.error('Broadcast stroke failed', error));
      }
    }

    function removeStrokeById(id) {
      const stroke = strokeMap.get(id);
      if (!stroke) return null;
      strokeMap.delete(id);
      const idx = strokes.findIndex((item) => item.id === id);
      if (idx !== -1) {
        strokes.splice(idx, 1);
      }
      redraw();
      updateButtons();
      return stroke;
    }

    function findLastLocalStroke() {
      for (let i = strokes.length - 1; i >= 0; i -= 1) {
        if (strokes[i].userId === userId) {
          return strokes[i];
        }
      }
      return null;
    }

    function finishStroke() {
      if (!isDrawing) return;
      if (activePointerId !== null) {
        try {
          canvas.releasePointerCapture(activePointerId);
        } catch (error) {
          console.warn('Pointer release failed', error);
        }
        activePointerId = null;
      }
      isDrawing = false;
      if (currentStroke && currentStroke.points.length > 0) {
        currentStroke.createdAt = Date.now();
        addStroke(currentStroke, { broadcast: true });
        undoneStack.length = 0;
      }
      currentStroke = null;
      redraw();
    }

    canvas.addEventListener('pointerdown', (evt) => {
      if (evt.button !== 0) return;
      activePointerId = evt.pointerId;
      if (canvas.setPointerCapture) {
        try {
          canvas.setPointerCapture(activePointerId);
        } catch (error) {
          console.warn('Pointer capture failed', error);
        }
      }
      isDrawing = true;
      const point = getPoint(evt);
      currentStroke = {
        id: `${userId}-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`,
        userId,
        clientId,
        color: currentColor,
        size: brushSize,
        points: [point],
        createdAt: Date.now(),
      };
      redraw();
    });

    canvas.addEventListener('pointermove', (evt) => {
      if (!isDrawing || !currentStroke) return;
      const point = getPoint(evt);
      const lastPoint = currentStroke.points[currentStroke.points.length - 1];
      const dx = point.x - lastPoint.x;
      const dy = point.y - lastPoint.y;
      if (Math.hypot(dx, dy) < 0.8) return;
      currentStroke.points.push(point);
      redraw();
    });

    const endEvents = ['pointerup', 'pointercancel', 'pointerleave'];
    endEvents.forEach((name) => {
      canvas.addEventListener(name, () => {
        finishStroke();
      });
    });

    undoBtn.addEventListener('click', () => {
      const stroke = findLastLocalStroke();
      if (!stroke) return;
      const removed = removeStrokeById(stroke.id);
      if (!removed) return;
      undoneStack.push(removed);
      channel
        .send({
          type: 'broadcast',
          event: 'remove',
          payload: { strokeId: removed.id, userId, clientId },
        })
        .catch((error) => console.error('Broadcast remove failed', error));
    });

    redoBtn.addEventListener('click', () => {
      if (undoneStack.length === 0) return;
      const stroke = undoneStack.pop();
      stroke.createdAt = Date.now();
      addStroke(stroke, { broadcast: true });
    });

    clearBtn.addEventListener('click', () => {
      let removedAny = false;
      while (true) {
        const stroke = findLastLocalStroke();
        if (!stroke) break;
        const removed = removeStrokeById(stroke.id);
        if (!removed) break;
        undoneStack.push(removed);
        removedAny = true;
      }
      if (removedAny) {
        channel
          .send({
            type: 'broadcast',
            event: 'clear',
            payload: { userId, clientId },
          })
          .catch((error) => console.error('Broadcast clear failed', error));
      }
    });

    channel.on('broadcast', { event: 'stroke' }, ({ payload }) => {
      if (!payload || payload.clientId === clientId) return;
      addStroke(payload.stroke, { broadcast: false });
    });

    channel.on('broadcast', { event: 'remove' }, ({ payload }) => {
      if (!payload) return;
      if (payload.clientId === clientId) return;
      removeStrokeById(payload.strokeId);
    });

    channel.on('broadcast', { event: 'clear' }, ({ payload }) => {
      if (!payload) return;
      if (payload.clientId === clientId) return;
      const targetUser = payload.userId;
      const idsToDelete = strokes.filter((stroke) => stroke.userId === targetUser).map((stroke) => stroke.id);
      idsToDelete.forEach((id) => removeStrokeById(id));
    });

    channel.on('broadcast', { event: 'request_state' }, ({ payload }) => {
      if (!payload || payload.clientId === clientId) return;
      if (strokes.length === 0) return;
      channel
        .send({
          type: 'broadcast',
          event: 'state',
          payload: {
            targetClientId: payload.clientId,
            fromClientId: clientId,
            strokes,
          },
        })
        .catch((error) => console.error('Broadcast state failed', error));
    });

    channel.on('broadcast', { event: 'state' }, ({ payload }) => {
      if (!payload || payload.targetClientId !== clientId) return;
      const incoming = payload.strokes || [];
      incoming.forEach((stroke) => {
        addStroke(stroke, { broadcast: false });
      });
    });

    channel.subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        setStatus('Connected', 'ready');
        channel
          .send({
            type: 'broadcast',
            event: 'request_state',
            payload: { clientId, userId },
          })
          .catch((error) => console.error('State request failed', error));
      } else if (status === 'TIMED_OUT' || status === 'CHANNEL_ERROR') {
        setStatus('Connection lost', 'error');
      } else if (status === 'CLOSED') {
        setStatus('Disconnected', 'error');
      } else {
        setStatus('Connecting…', 'connecting');
      }
    });

    updateButtons();
    setStatus('Connecting…', 'connecting');

    window.addEventListener('beforeunload', () => {
      supabase.removeChannel(channel);
    });
  </script>
</body>
</html>
