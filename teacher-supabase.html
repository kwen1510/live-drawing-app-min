<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Teacher ‚Ä¢ Live Drawing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              display: ['"Plus Jakarta Sans"', "ui-sans-serif", "system-ui"],
            },
            colors: {
              brand: {
                500: "#6366f1",
                600: "#4f46e5",
                700: "#4338ca",
              },
            },
          },
        },
      };
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Plus Jakarta Sans", ui-sans-serif, system-ui;
      }
      #modal {
        display: none;
      }
      #modal.open {
        display: flex;
      }
      .color-btn {
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 9999px;
        border: 3px solid transparent;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
      }
      .color-btn:hover {
        transform: scale(1.08);
      }
      .color-btn.active {
        box-shadow:
          0 0 0 3px rgba(255, 255, 255, 0.85),
          0 0 0 6px rgba(30, 41, 59, 0.85);
      }
      .tool-btn,
      .action-btn {
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
      }
      .tool-btn:hover,
      .action-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
      }
      .tool-btn.active {
        background: linear-gradient(135deg, #4f46e5, #4338ca);
        color: #fff;
        border-color: transparent;
        box-shadow: 0 10px 25px rgba(79, 70, 229, 0.35);
      }
      .action-btn:disabled,
      .tool-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .feedback-toast {
        opacity: 0;
        transform: translate(-50%, 20px);
        transition:
          opacity 0.25s ease,
          transform 0.25s ease;
        pointer-events: none;
      }
      .feedback-toast.show {
        opacity: 1;
        transform: translate(-50%, 0);
      }
      #overlay {
        position: absolute;
        inset: 0;
        pointer-events: auto;
        cursor: crosshair;
      }
    </style>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="absolute inset-0 -z-10 overflow-hidden">
      <div
        class="absolute -top-48 -right-32 h-[32rem] w-[32rem] rounded-full bg-gradient-to-br from-brand-100 to-sky-100 blur-3xl"
      ></div>
      <div
        class="absolute -bottom-52 -left-24 h-[36rem] w-[36rem] rounded-full bg-gradient-to-br from-indigo-100 to-violet-100 blur-3xl"
      ></div>
      <div
        class="absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(79,70,229,0.08),_transparent_60%)]"
      ></div>
    </div>

    <main
      class="relative mx-auto flex min-h-screen w-full max-w-7xl flex-col gap-10 px-6 py-10"
    >
      <header
        class="rounded-3xl border border-slate-200 bg-white p-1 shadow-2xl shadow-brand-200/60"
      >
        <div
          class="flex flex-col gap-6 rounded-[2.8rem] border border-slate-200 bg-gradient-to-br from-white to-slate-100 p-8 md:flex-row md:items-center md:justify-between"
        >
          <div class="space-y-4">
            <div class="flex items-center gap-3">
              <span
                class="inline-flex h-12 w-12 items-center justify-center rounded-2xl bg-brand-100 text-2xl"
                >üìä</span
              >
              <div>
                <h1 class="text-3xl font-semibold tracking-tight text-slate-900">
                  Teacher Control Room
                </h1>
                <p class="text-sm text-slate-600">
                  Launch a session, monitor every canvas, and annotate live.
                </p>
              </div>
            </div>
            <div
              class="flex flex-col gap-3 rounded-2xl border border-slate-200 bg-white p-4 md:flex-row md:items-center md:gap-4"
            >
              <div
                class="flex flex-col gap-2 md:flex-row md:items-center md:gap-3"
              >
                <label
                  for="sessionInput"
                  class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500"
                  >Session code</label
                >
                <input
                  id="sessionInput"
                  type="text"
                  maxlength="10"
                  value="TEST123"
                  class="w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-base font-semibold uppercase tracking-[0.2em] text-slate-900 shadow focus:border-brand-500 focus:outline-none focus:ring-4 focus:ring-brand-500/30 md:w-40"
                  aria-label="Session code"
                />
              </div>
              <button
                id="startSessionBtn"
                class="inline-flex items-center justify-center rounded-xl bg-gradient-to-br from-brand-600 to-indigo-500 px-6 py-3 text-sm font-semibold text-white shadow-lg shadow-brand-700/30 transition hover:translate-y-[-1px] hover:shadow-xl focus:outline-none focus-visible:ring-4 focus-visible:ring-brand-500/40"
              >
                Start session
              </button>
              <span
                id="status"
                class="inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-slate-600 ring-1 ring-slate-200"
                aria-live="polite"
                >Not connected</span
              >
            </div>
            <div
              id="sessionInfo"
              class="hidden w-full flex flex-wrap items-center justify-between gap-4 rounded-2xl border border-slate-200 bg-white p-4 text-sm text-slate-600"
            >
              <div class="flex items-center gap-3">
                <span
                  class="rounded-full bg-brand-100 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-brand-700"
                  >Active session</span
                >
                <span class="text-lg font-semibold text-slate-900" id="sessionCode"
                  >‚Äî</span
                >
              </div>
              <div class="flex items-center gap-3 text-sm font-medium">
                <span
                  class="rounded-full bg-emerald-100 px-3 py-1 text-emerald-700"
                  >Students online</span
                >
                <span id="studentCount" class="text-lg font-semibold text-slate-900"
                  >0</span
                >
              </div>
            </div>
          </div>
          <div class="hidden h-full w-px bg-slate-200 md:block"></div>
          <div
            class="flex-1 space-y-6 rounded-3xl border border-slate-200 bg-white p-6"
          >
            <div class="flex flex-col gap-4">
              <div class="flex flex-wrap items-center justify-between gap-3">
                <h2 class="text-base font-semibold tracking-tight text-slate-900">
                  Session controls
                </h2>
                <button
                  id="voiceToggle"
                  type="button"
                  class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-slate-50 px-4 py-2 text-sm font-semibold text-slate-700 shadow-sm transition hover:bg-slate-100 focus:outline-none focus-visible:ring-4 focus-visible:ring-brand-500/20"
                  aria-pressed="true"
                >
                  <span id="voiceIcon" aria-hidden="true">üîä</span>
                  <span id="voiceLabel">Voice feedback on</span>
                </button>
              </div>
              <dl class="grid gap-4 sm:grid-cols-2">
                <div class="rounded-2xl border border-slate-200 bg-slate-50/80 p-4">
                  <dt class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500">
                    Latest activity
                  </dt>
                  <dd
                    id="activityLabel"
                    class="mt-2 text-sm font-medium text-slate-700"
                  >
                    Waiting for session updates
                  </dd>
                </div>
                <div class="rounded-2xl border border-slate-200 bg-slate-50/80 p-4">
                  <dt class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500">
                    Connection status
                  </dt>
                  <dd
                    id="statusLabel"
                    class="mt-2 text-sm font-medium text-slate-700"
                  >
                    Not connected
                  </dd>
                </div>
              </dl>
              <p class="text-xs text-slate-500">
                When voice feedback is on, key events such as connections,
                joins, and annotation updates are spoken aloud.
              </p>
            </div>
          </div>
        </div>
      </header>

      <section class="space-y-6">
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold text-slate-900">Student canvases</h2>
        </div>
        <div
          id="students"
          class="grid gap-6 sm:grid-cols-2 xl:grid-cols-3"
        ></div>
        <div
          id="emptyState"
          class="flex flex-col items-center justify-center gap-3 rounded-3xl border border-dashed border-slate-200 bg-slate-100 p-16 text-center text-slate-600"
        >
          <span class="text-3xl">üëã</span>
          <p class="text-lg font-semibold text-slate-900">
            Waiting for students to join
          </p>
          <p class="max-w-sm text-sm text-slate-600">
            Share the session code
            <span class="font-semibold text-slate-900">TEST123</span> so students
            can connect instantly.
          </p>
        </div>
      </section>
    </main>

    <div
      id="feedbackToast"
      class="feedback-toast fixed bottom-6 left-1/2 z-50 -translate-x-1/2 rounded-full bg-white px-5 py-2 text-sm font-semibold text-slate-900 shadow-xl shadow-slate-300/50"
    >
      Action completed
    </div>

    <div
      id="modal"
      class="modal fixed inset-0 z-40 hidden flex-col items-center justify-center bg-slate-900/20 px-6 py-10 backdrop-blur-sm"
    >
      <div class="flex w-full max-w-6xl flex-col gap-6">
        <div
          class="flex flex-col gap-4 rounded-3xl border border-slate-200 bg-white p-6 shadow-xl shadow-brand-200/40"
        >
          <div
            class="flex flex-col items-start gap-4 md:flex-row md:items-center md:justify-between"
          >
            <div class="flex items-center gap-3 text-left">
              <span
                class="inline-flex h-12 w-12 items-center justify-center rounded-2xl bg-brand-100 text-2xl"
                >‚úèÔ∏è</span
              >
              <div>
                <h2 id="modalTitle" class="text-2xl font-semibold text-slate-900">
                  Annotating Student
                </h2>
                <p class="text-sm text-slate-600">
                  Use undo
                  <kbd
                    class="rounded bg-slate-200 px-1.5 py-0.5 text-[0.65rem] font-semibold uppercase text-slate-800"
                    >‚åò</kbd
                  ><kbd
                    class="rounded bg-slate-200 px-1.5 py-0.5 text-[0.65rem] font-semibold uppercase text-slate-800"
                    >Z</kbd
                  >
                  and redo shortcuts to work even faster.
                </p>
              </div>
            </div>
            <button
              id="closeModal"
              class="inline-flex items-center justify-center rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100 focus:outline-none focus-visible:ring-4 focus-visible:ring-brand-200"
            >
              Close
            </button>
          </div>

          <div
            class="toolbar flex flex-wrap items-center justify-center gap-3 rounded-full border border-slate-200 bg-slate-50 px-6 py-3 shadow-lg shadow-slate-200"
          >
            <div
              class="flex items-center gap-2"
              role="group"
              aria-label="Annotation color"
            >
              <button
                class="color-btn"
                style="background: #dc2626"
                data-color="#dc2626"
                title="Red"
              ></button>
              <button
                class="color-btn"
                style="background: #9333ea"
                data-color="#9333ea"
                title="Purple"
              ></button>
              <button
                class="color-btn"
                style="background: #14b8a6"
                data-color="#14b8a6"
                title="Teal"
              ></button>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <div
              class="flex items-center gap-2"
              role="group"
              aria-label="Annotation tool"
            >
              <button
                class="tool-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600"
                data-tool="pen"
              >
                Pen
              </button>
              <button
                class="tool-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600"
                data-tool="eraser"
              >
                Eraser
              </button>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <div class="flex items-center gap-3" aria-label="Brush size">
              <span
                class="text-xs font-semibold uppercase tracking-wide text-slate-500"
                >Size</span
              >
              <input
                type="range"
                id="brushSize"
                min="1"
                max="24"
                value="4"
                class="h-1.5 w-28 cursor-pointer appearance-none rounded-full bg-slate-200"
              />
              <span
                id="sizeDisplay"
                class="text-sm font-semibold text-slate-700"
                >4</span
              >
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <div
              class="flex items-center gap-2"
              aria-label="Annotation actions"
            >
              <button
                class="action-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600 disabled:opacity-40"
                id="undoBtn"
                title="Undo (‚åò/Ctrl + Z)"
                disabled
              >
                Undo
              </button>
              <button
                class="action-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600 disabled:opacity-40"
                id="redoBtn"
                title="Redo (‚áß + ‚åò/Ctrl + Z)"
                disabled
              >
                Redo
              </button>
              <button
                class="action-btn rounded-full border border-rose-200 bg-rose-500/10 px-4 py-2 text-sm font-semibold text-rose-600"
                id="clearBtn"
                title="Clear annotations"
              >
                Clear
              </button>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <button
              class="stylus-indicator rounded-full border border-slate-200 bg-blue-100 px-4 py-2 text-xs font-semibold uppercase tracking-wide text-blue-800"
              id="stylusToggle"
            >
              Stylus mode (pen only)
            </button>
          </div>
        </div>
        <div
          class="relative overflow-hidden rounded-3xl border border-slate-200 bg-white p-4 shadow-2xl shadow-slate-200"
        >
          <div
            class="relative mx-auto max-w-full overflow-hidden rounded-2xl border border-slate-200 shadow-inner"
          >
            <canvas
              id="bigCanvas"
              width="800"
              height="600"
              class="block h-auto max-h-[70vh] w-full rounded-2xl bg-white"
            ></canvas>
            <canvas
              id="overlay"
              width="800"
              height="600"
              class="block h-auto max-h-[70vh] w-full rounded-2xl"
            ></canvas>
          </div>
        </div>
      </div>
    </div>

    <script>
      window.SUPABASE_URL = "https://eytswszeopdxmtxxbkrb.supabase.co";
      window.SUPABASE_ANON_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5dHN3c3plb3BkeG10eHhpY3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1NTI5ODQsImV4cCI6MjA3NDEyODk4NH0.7skddGtrUoXluvK9JDS54bpmKCxVYeofzWATmJIgABE";
    </script>
    <script type="module">
      import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.4/+esm";

      const studentsDiv = document.getElementById("students");
      const emptyState = document.getElementById("emptyState");
      const modal = document.getElementById("modal");
      const bigCanvas = document.getElementById("bigCanvas");
      const bigCtx = bigCanvas.getContext("2d");
      const overlay = document.getElementById("overlay");
      const overlayCtx = overlay.getContext("2d");
      const modalTitle = document.getElementById("modalTitle");
      const closeModal = document.getElementById("closeModal");
      const status = document.getElementById("status");
      const sessionInfo = document.getElementById("sessionInfo");
      const sessionCodeDisplay = document.getElementById("sessionCode");
      const studentCount = document.getElementById("studentCount");
      const sessionInput = document.getElementById("sessionInput");
      const feedbackToast = document.getElementById("feedbackToast");
      const activityLabel = document.getElementById("activityLabel");
      const statusLabel = document.getElementById("statusLabel");
      const voiceToggle = document.getElementById("voiceToggle");
      const voiceIcon = document.getElementById("voiceIcon");
      const voiceLabel = document.getElementById("voiceLabel");

      const statusStyles = {
        idle: "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-slate-600 ring-1 ring-slate-200 bg-slate-100",
        connecting:
          "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-amber-700 ring-1 ring-amber-200 bg-amber-50",
        connected:
          "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-emerald-700 ring-1 ring-emerald-200 bg-emerald-50",
        error:
          "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-rose-700 ring-1 ring-rose-200 bg-rose-50",
      };

      let supabase, channel;
      let sessionCode;
      let students = new Map();
      let currentStudent = null;
      let isAnnotating = false;
      let isErasingAnnotation = false;
      let deletedAnnotationIds = new Set();

      let connectionReady = false;

      let annotationHistory = [];
      let annotationHistoryStep = -1;

      const speechSupported =
        "speechSynthesis" in window &&
        typeof SpeechSynthesisUtterance !== "undefined";
      let voiceEnabled = speechSupported;

      function logActivity(message) {
        if (activityLabel && message) {
          activityLabel.textContent = message;
        }
      }

      function speakMessage(message) {
        if (!voiceEnabled || !speechSupported || !message) return;
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.rate = 1;
        utterance.pitch = 1;
        try {
          window.speechSynthesis.cancel();
        } catch (err) {
          console.warn("Unable to cancel previous speech output", err);
        }
        window.speechSynthesis.speak(utterance);
      }

      function updateVoiceToggle() {
        if (!voiceToggle) return;
        voiceToggle.setAttribute("aria-pressed", String(voiceEnabled));
        if (voiceIcon) {
          voiceIcon.textContent = voiceEnabled ? "üîä" : "üîá";
        }
        if (voiceLabel) {
          voiceLabel.textContent = voiceEnabled
            ? "Voice feedback on"
            : "Voice feedback off";
        }
        if (!speechSupported) {
          voiceToggle.disabled = true;
          voiceToggle.classList.add("cursor-not-allowed", "opacity-60");
          if (voiceLabel) {
            voiceLabel.textContent = "Voice feedback unavailable";
          }
          if (voiceIcon) {
            voiceIcon.textContent = "üîá";
          }
        }
      }

      updateVoiceToggle();

      voiceToggle?.addEventListener("click", () => {
        if (!speechSupported) return;
        voiceEnabled = !voiceEnabled;
        updateVoiceToggle();
        showFeedback(
          voiceEnabled ? "Voice feedback enabled" : "Voice feedback muted",
        );
      });

      function resetStudentsUI() {
        students.clear();
        studentsDiv.innerHTML = "";
        emptyState.classList.remove("hidden");
        studentCount.textContent = "0";
        if (!connectionReady && activityLabel) {
          activityLabel.textContent = "Waiting for session updates";
        }
      }

      function cleanupChannel() {
        if (!channel) return;
        try {
          channel.unsubscribe().catch((err) => {
            console.warn("Unable to unsubscribe from previous channel", err);
          });
        } catch (err) {
          console.warn("Channel cleanup failed", err);
        }
        channel = null;
      }

      function handleConnectionError(
        message,
        statusMessage = "Connection error",
      ) {
        cleanupChannel();
        connectionReady = false;
        updateStatus("error", statusMessage);
        sessionInput.disabled = false;
        startSessionBtn.disabled = false;
        sessionInfo.classList.add("hidden");
        sessionCodeDisplay.textContent = "‚Äî";
        modal.classList.remove("open");
        currentStudent = null;
        resetStudentsUI();
        showFeedback(message);
      }

      function handleChannelStatus(channelStatus) {
        if (channelStatus === "SUBSCRIBED") {
          connectionReady = true;
          updateStatus("connected", "Connected");
          sessionInfo.classList.remove("hidden");
          sessionCodeDisplay.textContent = sessionCode;
          showFeedback("Session connected");
          return;
        }

        if (channelStatus === "CHANNEL_ERROR") {
          handleConnectionError(
            "Connection error. Check Supabase credentials and retry.",
            "Connection error",
          );
        } else if (channelStatus === "TIMED_OUT") {
          handleConnectionError(
            "Connection timed out. Tap ‚ÄúStart session‚Äù to retry.",
            "Connection timed out",
          );
        } else if (channelStatus === "CLOSED" && connectionReady) {
          handleConnectionError(
            "Connection closed. Tap ‚ÄúStart session‚Äù to reconnect.",
            "Connection closed",
          );
        }
      }

      const colorBtns = document.querySelectorAll(".color-btn");
      const toolBtns = document.querySelectorAll(".tool-btn");
      const brushSizeInput = document.getElementById("brushSize");
      const sizeDisplay = document.getElementById("sizeDisplay");
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      const clearBtn = document.getElementById("clearBtn");
      const stylusToggle = document.getElementById("stylusToggle");
      const startSessionBtn = document.getElementById("startSessionBtn");

      let currentColor = "#dc2626";
      let currentTool = "pen";
      let brushSize = 4;
      let stylusOnly = true;
      let lastTeacherPoint = null;

      function updateStatus(state, label) {
        status.textContent = label;
        status.className = statusStyles[state] || statusStyles.idle;
        if (statusLabel) {
          statusLabel.textContent = label;
        }
      }

      function showFeedback(message) {
        if (!message) return;
        logActivity(message);
        if (feedbackToast) {
          feedbackToast.textContent = message;
          feedbackToast.classList.add("show");
          clearTimeout(showFeedback._timeout);
          showFeedback._timeout = setTimeout(() => {
            feedbackToast.classList.remove("show");
          }, 1600);
        }
        speakMessage(message);
      }

      function cloneAnnotations(annotations = []) {
        return annotations.map((annotation) => ({
          ...annotation,
          points: annotation.points
            ? annotation.points.map((point) => ({ ...point }))
            : [],
        }));
      }

      function syncHistoryToStudent(student) {
        student.annotationHistory = annotationHistory.map(cloneAnnotations);
        student.annotationHistoryStep = annotationHistoryStep;
      }

      function loadAnnotationHistory(student) {
        annotationHistory = student.annotationHistory
          ? student.annotationHistory.map(cloneAnnotations)
          : [];
        annotationHistoryStep =
          typeof student.annotationHistoryStep === "number"
            ? student.annotationHistoryStep
            : -1;

        if (annotationHistory.length === 0) {
          annotationHistory.push(cloneAnnotations(student.teacherAnnotations));
          annotationHistoryStep = annotationHistory.length - 1;
        } else if (
          annotationHistoryStep < 0 ||
          annotationHistoryStep >= annotationHistory.length
        ) {
          annotationHistoryStep = annotationHistory.length - 1;
        }

        restoreAnnotationState();
      }

      function saveAnnotationState(student) {
        if (!student) return;
        if (annotationHistoryStep < annotationHistory.length - 1) {
          annotationHistory = annotationHistory.slice(
            0,
            annotationHistoryStep + 1,
          );
        }

        annotationHistory.push(cloneAnnotations(student.teacherAnnotations));
        annotationHistoryStep = annotationHistory.length - 1;
        syncHistoryToStudent(student);
        updateAnnotationHistoryButtons();
      }

      function restoreAnnotationState() {
        const student = students.get(currentStudent);
        if (!student) return;
        const snapshot = annotationHistory[annotationHistoryStep] || [];
        student.teacherAnnotations = cloneAnnotations(snapshot);

        overlayCtx.clearRect(0, 0, 800, 600);
        redrawStoredAnnotations(student);
        updateStudentPreview(student.username);
        syncHistoryToStudent(student);
        updateAnnotationHistoryButtons();
      }

      function updateAnnotationHistoryButtons() {
        undoBtn.disabled = annotationHistoryStep <= 0;
        redoBtn.disabled =
          annotationHistoryStep >= annotationHistory.length - 1;
      }

      function getVisibleAnnotationIds(student) {
        if (!student) return new Set();
        return new Set(
          student.teacherAnnotations.map((annotation) => annotation.id),
        );
      }

      function computeAnnotationDiff(oldVisibleIds, newVisibleIds, student) {
        const added = [];
        const removed = [];

        newVisibleIds.forEach((id) => {
          if (!oldVisibleIds.has(id)) {
            const annotation = student.teacherAnnotations.find(
              (a) => a.id === id,
            );
            if (annotation) {
              added.push({
                id: annotation.id,
                color: annotation.color,
                size: annotation.size,
                points: annotation.points,
              });
            }
          }
        });

        oldVisibleIds.forEach((id) => {
          if (!newVisibleIds.has(id)) {
            removed.push(id);
          }
        });

        return { added, removed };
      }

      updateStatus("idle", "Not connected");

      window.addEventListener("DOMContentLoaded", () => {
        sessionInput.value = "TEST123";
        setTimeout(startSession, 100);
      });

      async function startSession() {
        sessionCode = sessionInput.value.trim().toUpperCase();
        if (!sessionCode) {
          alert("Please enter a session code");
          return;
        }

        connectionReady = false;
        resetStudentsUI();
        modal.classList.remove("open");
        currentStudent = null;
        sessionInfo.classList.add("hidden");
        sessionCodeDisplay.textContent = "‚Äî";

        sessionInput.disabled = true;
        startSessionBtn.disabled = true;
        updateStatus("connecting", "Connecting‚Ä¶");
        logActivity("Connecting to session‚Ä¶");
        speakMessage("Connecting to session");
        await setupSupabase();
      }

      startSessionBtn.addEventListener("click", startSession);
      sessionInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") startSession();
      });

      async function setupSupabase() {
        try {
          cleanupChannel();
          connectionReady = false;

          if (!window.SUPABASE_URL || !window.SUPABASE_ANON_KEY) {
            console.error("Missing Supabase configuration.");
            handleConnectionError(
              "Missing Supabase credentials. Update the configuration and retry.",
              "Missing Supabase keys",
            );
            return;
          }

          supabase = createClient(
            window.SUPABASE_URL,
            window.SUPABASE_ANON_KEY,
          );

          channel = supabase.channel(`minimal-${sessionCode}`, {
            config: { broadcast: { ack: false } },
          });

          channel.on("broadcast", { event: "student_ready" }, ({ payload }) => {
            addStudent(payload.username);
            showFeedback(`${payload.username} joined the session`);
          });

          channel.on(
            "broadcast",
            { event: "student_stroke_end" },
            ({ payload }) => {
              const student = students.get(payload.username);
              if (student) {
                const stroke = {
                  id: payload.stroke.id,
                  color: payload.stroke.color,
                  size: payload.stroke.size,
                  points: payload.stroke.points,
                  isTeacher: false,
                };
                student.strokes.push(stroke);
                redrawStudentCanvas(student);
                updateStudentPreview(student.username);
              }
            },
          );

          channel.on(
            "broadcast",
            { event: "student_state_change" },
            ({ payload }) => {
              const student = students.get(payload.username);
              if (student) {
                payload.added.forEach((strokeData) => {
                  if (!student.strokes.find((s) => s.id === strokeData.id)) {
                    const stroke = {
                      id: strokeData.id,
                      color: strokeData.color,
                      size: strokeData.size,
                      points: strokeData.points,
                      isTeacher: false,
                    };
                    student.strokes.push(stroke);
                  }
                });

                payload.removed.forEach((id) => {
                  const index = student.strokes.findIndex((s) => s.id === id);
                  if (index >= 0) {
                    student.strokes.splice(index, 1);
                  }
                });

                redrawStudentCanvas(student);
                updateStudentPreview(student.username);
              }
            },
          );

          channel.on(
            "broadcast",
            { event: "student_stroke_delete" },
            ({ payload }) => {
              const student = students.get(payload.username);
              if (student) {
                student.strokes = student.strokes.filter(
                  (s) => s.id !== payload.strokeId,
                );
                redrawStudentCanvas(student);
                updateStudentPreview(student.username);
              }
            },
          );

          channel.on("broadcast", { event: "student_clear" }, ({ payload }) => {
            const student = students.get(payload.username);
            if (student) {
              student.strokes = [];
              redrawStudentCanvas(student);
              updateStudentPreview(student.username);
            }
          });

          let handledDuringSubscribe = false;
          const subscribeStatus = await channel.subscribe((channelStatus) => {
            handleChannelStatus(channelStatus);
            if (channelStatus !== "SUBSCRIBED") {
              handledDuringSubscribe = true;
            }
          });

          if (subscribeStatus !== "SUBSCRIBED" && !handledDuringSubscribe) {
            handleConnectionError(
              "Unable to connect to Supabase. Tap ‚ÄúStart session‚Äù to retry.",
            );
          }
        } catch (err) {
          console.error("Failed to initialise Supabase channel", err);
          handleConnectionError(
            "Unable to connect to Supabase. Check your connection and retry.",
          );
        }
      }

      function addStudent(username) {
        if (students.has(username)) return;

        emptyState.classList.add("hidden");

        const canvas = document.createElement("canvas");
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, 800, 600);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        students.set(username, {
          username,
          canvas,
          ctx,
          strokes: [],
          teacherAnnotations: [],
          currentAnnotation: null,
          annotationHistory: [],
          annotationHistoryStep: -1,
        });

        const card = document.createElement("div");
        card.className =
          "flex flex-col gap-4 rounded-3xl border border-slate-200 bg-white p-5 shadow-xl shadow-slate-200";
        card.innerHTML = `
                <div class="flex items-center justify-between gap-3">
                    <div class="flex items-center gap-3">
                        <span class="inline-flex h-10 w-10 items-center justify-center rounded-2xl bg-emerald-100 text-xl">üë©‚Äçüéì</span>
                        <h3 class="text-lg font-semibold text-slate-900">${username}</h3>
                    </div>
                    <button data-username="${username}" class="annotate-btn inline-flex items-center gap-2 rounded-full bg-brand-600 px-4 py-2 text-sm font-semibold text-white shadow-md shadow-brand-700/30 transition hover:bg-brand-500" title="Open canvas">
                        Annotate
                        <span aria-hidden="true">‚Üí</span>
                    </button>
                </div>
                <div class="overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-inner">
                    <canvas width="800" height="600" class="block h-full w-full"></canvas>
                </div>
            `;

        card
          .querySelector(".annotate-btn")
          .addEventListener("click", () => annotate(username));
        const previewCtx = card.querySelector("canvas").getContext("2d");
        previewCtx.fillStyle = "#ffffff";
        previewCtx.fillRect(0, 0, 800, 600);
        studentsDiv.appendChild(card);
        studentCount.textContent = students.size;
      }

      function redrawStudentCanvas(student) {
        if (!student) return;
        student.ctx.fillStyle = "white";
        student.ctx.fillRect(0, 0, 800, 600);

        student.strokes.forEach((stroke) => {
          if (!stroke?.points?.length) return;

          student.ctx.strokeStyle = stroke.color;
          student.ctx.lineWidth = stroke.size;
          student.ctx.lineCap = "round";
          student.ctx.lineJoin = "round";

          if (stroke.points.length === 1) {
            const point = stroke.points[0];
            student.ctx.beginPath();
            student.ctx.arc(point.x, point.y, stroke.size / 2, 0, Math.PI * 2);
            student.ctx.fillStyle = stroke.color;
            student.ctx.fill();
            return;
          }

          student.ctx.beginPath();
          student.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);

          for (let i = 1; i < stroke.points.length; i++) {
            const prev = stroke.points[i - 1];
            const curr = stroke.points[i];
            const midX = (prev.x + curr.x) / 2;
            const midY = (prev.y + curr.y) / 2;
            student.ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
          }

          student.ctx.stroke();
        });
      }

      function updateStudentPreview(username) {
        const student = students.get(username);
        if (!student) return;

        const card = Array.from(studentsDiv.children).find(
          (c) => c.querySelector("h3")?.textContent === username,
        );
        if (!card) return;

        const previewCanvas = card.querySelector("canvas");
        const previewCtx = previewCanvas.getContext("2d");
        previewCtx.clearRect(0, 0, 800, 600);
        previewCtx.drawImage(student.canvas, 0, 0);

        if (student.teacherAnnotations.length > 0) {
          previewCtx.lineCap = "round";
          previewCtx.lineJoin = "round";
          student.teacherAnnotations.forEach((annotation) => {
            if (!annotation.points?.length) return;
            previewCtx.strokeStyle = annotation.color;
            previewCtx.lineWidth = annotation.size;
            previewCtx.beginPath();
            previewCtx.moveTo(annotation.points[0].x, annotation.points[0].y);
            for (let i = 1; i < annotation.points.length; i++) {
              const prev = annotation.points[i - 1];
              const curr = annotation.points[i];
              const midX = (prev.x + curr.x) / 2;
              const midY = (prev.y + curr.y) / 2;
              previewCtx.quadraticCurveTo(prev.x, prev.y, midX, midY);
            }
            previewCtx.stroke();
          });
        }
      }

      window.annotate = function (username) {
        currentStudent = username;
        const student = students.get(username);
        if (!student) return;

        bigCtx.clearRect(0, 0, 800, 600);
        bigCtx.fillStyle = "white";
        bigCtx.fillRect(0, 0, 800, 600);
        bigCtx.drawImage(student.canvas, 0, 0);

        overlayCtx.clearRect(0, 0, 800, 600);
        redrawStoredAnnotations(student);

        modalTitle.textContent = `Annotating ${username}`;
        modal.classList.add("open");

        loadAnnotationHistory(student);
        updateOverlaySize();
        updateAnnotationHistoryButtons();
        showFeedback(`Annotating ${username}`);
      };

      closeModal.addEventListener("click", () => {
        modal.classList.remove("open");
        currentStudent = null;
      });

      function redrawStoredAnnotations(student) {
        overlayCtx.globalCompositeOperation = "source-over";
        student.teacherAnnotations.forEach((annotation) => {
          if (!annotation.points?.length) return;

          if (annotation.points.length === 1) {
            const point = annotation.points[0];
            overlayCtx.beginPath();
            overlayCtx.arc(
              point.x,
              point.y,
              (annotation.size || 4) / 2,
              0,
              Math.PI * 2,
            );
            overlayCtx.fillStyle = annotation.color || "#dc2626";
            overlayCtx.fill();
            return;
          }

          overlayCtx.strokeStyle = annotation.color || "#dc2626";
          overlayCtx.lineWidth = annotation.size || 4;
          overlayCtx.lineCap = "round";
          overlayCtx.lineJoin = "round";

          overlayCtx.beginPath();
          overlayCtx.moveTo(annotation.points[0].x, annotation.points[0].y);

          for (let i = 1; i < annotation.points.length; i++) {
            const prev = annotation.points[i - 1];
            const curr = annotation.points[i];
            const midX = (prev.x + curr.x) / 2;
            const midY = (prev.y + curr.y) / 2;
            overlayCtx.quadraticCurveTo(prev.x, prev.y, midX, midY);
          }

          overlayCtx.stroke();
        });
      }

      function updateOverlaySize() {
        const rect = bigCanvas.getBoundingClientRect();
        overlay.style.width = `${rect.width}px`;
        overlay.style.height = `${rect.height}px`;
      }

      colorBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          colorBtns.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentColor = btn.dataset.color;
          if (currentTool === "eraser") {
            currentTool = "pen";
            updateToolButtons();
          }
        });
      });
      colorBtns[0]?.classList.add("active");

      toolBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          currentTool = btn.dataset.tool;
          updateToolButtons();
        });
      });

      function updateToolButtons() {
        toolBtns.forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.tool === currentTool);
        });
      }
      updateToolButtons();

      brushSizeInput.addEventListener("input", (e) => {
        brushSize = parseInt(e.target.value, 10);
        sizeDisplay.textContent = brushSize;
      });

      stylusToggle.addEventListener("click", () => {
        stylusOnly = !stylusOnly;
        stylusToggle.classList.toggle("bg-blue-100/80", stylusOnly);
        stylusToggle.classList.toggle("bg-slate-200/60", !stylusOnly);
        stylusToggle.textContent = stylusOnly
          ? "Stylus mode (pen only)"
          : "All inputs enabled";
      });

      function undoAnnotation() {
        if (annotationHistoryStep > 0) {
          const student = students.get(currentStudent);
          if (!student) return;
          const oldVisible = getVisibleAnnotationIds(student);
          annotationHistoryStep--;
          restoreAnnotationState();
          const newVisible = getVisibleAnnotationIds(student);
          const diff = computeAnnotationDiff(oldVisible, newVisible, student);
          if ((diff.added.length || diff.removed.length) && channel) {
            channel.send({
              type: "broadcast",
              event: "teacher_state_change",
              payload: {
                target: student.username,
                added: diff.added,
                removed: diff.removed,
              },
            });
          }
          showFeedback("Undo annotation");
        }
      }

      function redoAnnotation() {
        if (annotationHistoryStep < annotationHistory.length - 1) {
          const student = students.get(currentStudent);
          if (!student) return;
          const oldVisible = getVisibleAnnotationIds(student);
          annotationHistoryStep++;
          restoreAnnotationState();
          const newVisible = getVisibleAnnotationIds(student);
          const diff = computeAnnotationDiff(oldVisible, newVisible, student);
          if ((diff.added.length || diff.removed.length) && channel) {
            channel.send({
              type: "broadcast",
              event: "teacher_state_change",
              payload: {
                target: student.username,
                added: diff.added,
                removed: diff.removed,
              },
            });
          }
          showFeedback("Redo annotation");
        }
      }

      function clearAnnotations() {
        const student = students.get(currentStudent);
        if (!student) return;
        if (student.teacherAnnotations.length === 0) return;

        student.teacherAnnotations = [];
        overlayCtx.clearRect(0, 0, 800, 600);
        updateStudentPreview(student.username);
        saveAnnotationState(student);
        updateAnnotationHistoryButtons();

        if (channel) {
          channel.send({
            type: "broadcast",
            event: "teacher_clear",
            payload: { target: student.username },
          });
        }
        showFeedback("Cleared annotations");
      }

      undoBtn.addEventListener("click", undoAnnotation);
      redoBtn.addEventListener("click", redoAnnotation);
      clearBtn.addEventListener("click", clearAnnotations);

      function handleTeacherHotkeys(event) {
        if (!modal.classList.contains("open")) return;
        const isMeta = event.metaKey || event.ctrlKey;
        if (isMeta && event.key.toLowerCase() === "z") {
          event.preventDefault();
          if (event.shiftKey) {
            redoAnnotation();
          } else {
            undoAnnotation();
          }
        } else if (isMeta && event.key.toLowerCase() === "y") {
          event.preventDefault();
          redoAnnotation();
        } else if (event.key === "Backspace" && event.shiftKey) {
          event.preventDefault();
          clearAnnotations();
        }
      }

      window.addEventListener("keydown", handleTeacherHotkeys);

      overlay.addEventListener("pointerdown", (e) => {
        const student = students.get(currentStudent);
        if (!student) return;
        if (stylusOnly && e.pointerType !== "pen") return;

        const rect = overlay.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (800 / rect.width);
        const y = (e.clientY - rect.top) * (600 / rect.height);

        if (currentTool === "eraser") {
          isErasingAnnotation = true;
          deletedAnnotationIds = new Set();
          lastTeacherPoint = { x, y };
          deleteAnnotationsInPath(x, y, student);
        } else {
          isAnnotating = true;
          lastTeacherPoint = { x, y };
          student.currentAnnotation = {
            id: Date.now() + "-" + Math.random(),
            points: [{ x, y }],
            color: currentColor,
            size: brushSize,
            isTeacher: true,
          };

          overlayCtx.globalCompositeOperation = "source-over";
          overlayCtx.strokeStyle = currentColor;
          overlayCtx.lineWidth = brushSize;
          overlayCtx.lineCap = "round";
          overlayCtx.lineJoin = "round";
          overlayCtx.beginPath();
          overlayCtx.moveTo(x, y);
        }
      });

      overlay.addEventListener("pointermove", (e) => {
        const student = students.get(currentStudent);
        if (!student) return;

        const rect = overlay.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (800 / rect.width);
        const y = (e.clientY - rect.top) * (600 / rect.height);

        if (isErasingAnnotation) {
          deleteAnnotationsInPath(x, y, student);
          lastTeacherPoint = { x, y };
          return;
        }

        if (!isAnnotating || !student.currentAnnotation) return;

        if (lastTeacherPoint) {
          const midX = (lastTeacherPoint.x + x) / 2;
          const midY = (lastTeacherPoint.y + y) / 2;
          overlayCtx.quadraticCurveTo(
            lastTeacherPoint.x,
            lastTeacherPoint.y,
            midX,
            midY,
          );
          overlayCtx.stroke();
          overlayCtx.beginPath();
          overlayCtx.moveTo(midX, midY);
        }

        lastTeacherPoint = { x, y };
        student.currentAnnotation.points.push({ x, y });
      });

      overlay.addEventListener("pointerup", stopAnnotating);
      overlay.addEventListener("pointerleave", stopAnnotating);

      function stopAnnotating() {
        const student = students.get(currentStudent);
        if (!student) return;

        if (isErasingAnnotation) {
          isErasingAnnotation = false;
          lastTeacherPoint = null;
          if (deletedAnnotationIds.size > 0) {
            saveAnnotationState(student);
            const diff = {
              added: [],
              removed: Array.from(deletedAnnotationIds),
            };
            if (diff.removed.length && channel) {
              channel.send({
                type: "broadcast",
                event: "teacher_state_change",
                payload: { target: student.username, ...diff },
              });
            }
            showFeedback(
              `Removed ${deletedAnnotationIds.size} annotation${deletedAnnotationIds.size > 1 ? "s" : ""}`,
            );
          }
          deletedAnnotationIds.clear();
          return;
        }

        if (!isAnnotating || !student.currentAnnotation) return;

        if (student.currentAnnotation.points.length === 1) {
          const point = student.currentAnnotation.points[0];
          overlayCtx.beginPath();
          overlayCtx.arc(point.x, point.y, brushSize / 2, 0, Math.PI * 2);
          overlayCtx.fillStyle = currentColor;
          overlayCtx.fill();
        }

        student.teacherAnnotations.push(student.currentAnnotation);
        updateStudentPreview(student.username);
        saveAnnotationState(student);

        channel?.send({
          type: "broadcast",
          event: "teacher_stroke_end",
          payload: {
            target: student.username,
            stroke: {
              id: student.currentAnnotation.id,
              color: student.currentAnnotation.color,
              size: student.currentAnnotation.size,
              points: student.currentAnnotation.points,
            },
          },
        });

        student.currentAnnotation = null;
        isAnnotating = false;
        lastTeacherPoint = null;
        overlayCtx.globalCompositeOperation = "source-over";
        showFeedback("Annotation added");
      }

      function deleteAnnotationsInPath(x, y, student) {
        const eraserRadius = Math.max(30, brushSize * 3);
        let changed = false;

        for (let i = student.teacherAnnotations.length - 1; i >= 0; i--) {
          const annotation = student.teacherAnnotations[i];
          if (!annotation?.points?.length) continue;
          if (deletedAnnotationIds.has(annotation.id)) continue;

          if (
            annotation.points.some((point, index) => {
              const dist = Math.hypot(point.x - x, point.y - y);
              if (dist < eraserRadius + (annotation.size || 4) / 2) return true;
              if (index === 0) return false;
              const prevPoint = annotation.points[index - 1];
              return (
                distToSegmentSquared(
                  x,
                  y,
                  prevPoint.x,
                  prevPoint.y,
                  point.x,
                  point.y,
                ) <
                (eraserRadius + (annotation.size || 4) / 2) ** 2
              );
            })
          ) {
            deletedAnnotationIds.add(annotation.id);
            student.teacherAnnotations.splice(i, 1);
            channel?.send({
              type: "broadcast",
              event: "teacher_stroke_delete",
              payload: { target: student.username, strokeId: annotation.id },
            });
            changed = true;
          }
        }

        if (changed) {
          overlayCtx.clearRect(0, 0, 800, 600);
          redrawStoredAnnotations(student);
          updateStudentPreview(student.username);
        }
      }

      function distToSegmentSquared(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSq = dx * dx + dy * dy;
        if (lengthSq === 0) return (px - x1) ** 2 + (py - y1) ** 2;
        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
        t = Math.max(0, Math.min(1, t));
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        return (px - projX) ** 2 + (py - projY) ** 2;
      }

      window.addEventListener("resize", () => {
        if (modal.classList.contains("open")) {
          updateOverlaySize();
        }
      });
    </script>
  </body>
</html>
