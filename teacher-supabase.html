<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Teacher ‚Ä¢ Live Drawing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              display: ['"Plus Jakarta Sans"', "ui-sans-serif", "system-ui"],
            },
            colors: {
              brand: { 500:"#6366f1", 600:"#4f46e5", 700:"#4338ca" },
            },
          },
        },
      };
    </script>
    <script>
      /* Your Supabase settings */
      window.SUPABASE_URL = "https://eytswszeopdxmtxxbkrb.supabase.co";
      window.SUPABASE_ANON_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5dHN3c3plb3BkeG10eHhpY3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1NTI5ODQsImV4cCI6MjA3NDEyODk4NH0.7skddGtrUoXluvK9JDS54bpmKCxVYeofzWATmJIgABE";
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <style>
      body { font-family:"Plus Jakarta Sans", ui-sans-serif, system-ui; }
      #modal { display:none; } #modal.open { display:flex; }
      .color-btn { width:2.5rem; height:2.5rem; border-radius:9999px; border:3px solid transparent; transition: transform .2s, box-shadow .2s; }
      .color-btn:hover { transform:scale(1.08); }
      .color-btn.active { box-shadow: 0 0 0 3px rgba(255,255,255,.85), 0 0 0 6px rgba(30,41,59,.85); }
      .tool-btn,.action-btn { transition: transform .2s, box-shadow .2s; }
      .tool-btn:hover,.action-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(15,23,42,.15); }
      .tool-btn.active { background: linear-gradient(135deg, #4f46e5, #4338ca); color:#fff; border-color:transparent; box-shadow: 0 10px 25px rgba(79,70,229,.35); }
      .action-btn:disabled,.tool-btn:disabled { opacity:.4; cursor:not-allowed; box-shadow:none; transform:none; }
      .feedback-toast { opacity:0; transform: translate(-50%,20px); transition: opacity .25s, transform .25s; pointer-events:none; }
      .feedback-toast.show { opacity:1; transform: translate(-50%,0); }
      #overlay { position:absolute; inset:0; pointer-events:auto; cursor:crosshair; touch-action:none; }
      canvas { touch-action:none; }
    </style>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="absolute inset-0 -z-10 overflow-hidden">
      <div class="absolute -top-48 -right-32 h-[32rem] w-[32rem] rounded-full bg-gradient-to-br from-brand-100 to-sky-100 blur-3xl"></div>
      <div class="absolute -bottom-52 -left-24 h-[36rem] w-[36rem] rounded-full bg-gradient-to-br from-indigo-100 to-violet-100 blur-3xl"></div>
      <div class="absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(79,70,229,0.08),_transparent_60%)]"></div>
    </div>

    <main class="relative mx-auto flex min-h-screen w-full max-w-7xl flex-col gap-10 px-6 py-10">
      <header class="rounded-3xl border border-slate-200 bg-white p-1 shadow-2xl shadow-brand-200/60">
        <div class="flex flex-col gap-6 rounded-[2.8rem] border border-slate-200 bg-gradient-to-br from-white to-slate-100 p-8 md:flex-row md:items-center md:justify-between">
          <div class="space-y-4">
            <div class="flex items-center gap-3">
              <span class="inline-flex h-12 w-12 items-center justify-center rounded-2xl bg-brand-100 text-2xl">üìä</span>
              <div>
                <h1 class="text-3xl font-semibold tracking-tight text-slate-900">Teacher Control Room</h1>
                <p class="text-sm text-slate-600">Launch a session, monitor every canvas, and annotate live.</p>
              </div>
            </div>
            <div class="flex flex-col gap-3 rounded-2xl border border-slate-200 bg-white p-4 md:flex-row md:items-center md:gap-4">
              <div class="flex flex-col gap-2 md:flex-row md:items-center md:gap-3">
                <label for="sessionInput" class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500">Session code</label>
                <input id="sessionInput" type="text" maxlength="10" value="TEST123" class="w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-base font-semibold uppercase tracking-[0.2em] text-slate-900 shadow focus:border-brand-500 focus:outline-none focus:ring-4 focus:ring-brand-500/30 md:w-40" aria-label="Session code" />
              </div>
              <button id="startSessionBtn" class="inline-flex items-center justify-center rounded-xl bg-gradient-to-br from-brand-600 to-indigo-500 px-6 py-3 text-sm font-semibold text-white shadow-lg shadow-brand-700/30 transition hover:translate-y-[-1px] hover:shadow-xl focus:outline-none focus-visible:ring-4 focus-visible:ring-brand-500/40">
                Start session
              </button>
              <span id="status" class="inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-slate-600 ring-1 ring-slate-200" aria-live="polite">Not connected</span>
            </div>
            <div id="sessionInfo" class="hidden w-full flex flex-wrap items-center justify-between gap-4 rounded-2xl border border-slate-200 bg-white p-4 text-sm text-slate-600">
              <div class="flex items-center gap-3">
                <span class="rounded-full bg-brand-100 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-brand-700">Active session</span>
                <span class="text-lg font-semibold text-slate-900" id="sessionCode">‚Äî</span>
              </div>
              <div class="flex items-center gap-3 text-sm font-medium">
                <span class="rounded-full bg-emerald-100 px-3 py-1 text-emerald-700">Students online</span>
                <span id="studentCount" class="text-lg font-semibold text-slate-900">0</span>
              </div>
            </div>
          </div>
          <div class="hidden h-full w-px bg-slate-200 md:block"></div>
          <div class="flex-1 space-y-6 rounded-3xl border border-slate-200 bg-white p-6">
            <div class="flex flex-col gap-4">
              <h2 class="text-base font-semibold tracking-tight text-slate-900">Session controls</h2>
              <dl class="grid gap-4 sm:grid-cols-2">
                <div class="rounded-2xl border border-slate-200 bg-slate-50/80 p-4">
                  <dt class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500">Latest activity</dt>
                  <dd id="activityLabel" class="mt-2 text-sm font-medium text-slate-700">Waiting for session updates</dd>
                </div>
                <div class="rounded-2xl border border-slate-200 bg-slate-50/80 p-4">
                  <dt class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500">Connection status</dt>
                  <dd id="statusLabel" class="mt-2 text-sm font-medium text-slate-700">Not connected</dd>
                </div>
              </dl>
            </div>
          </div>
        </div>
      </header>

      <section class="space-y-6">
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold text-slate-900">Student canvases</h2>
        </div>
        <div id="students" class="grid gap-6 sm:grid-cols-2 xl:grid-cols-3"></div>
        <div id="emptyState" class="flex flex-col items-center justify-center gap-3 rounded-3xl border border-dashed border-slate-200 bg-slate-100 p-16 text-center text-slate-600">
          <span class="text-3xl">üëã</span>
          <p class="text-lg font-semibold text-slate-900">Waiting for students to join</p>
          <p class="max-w-sm text-sm text-slate-600">
            Share the session code <span class="font-semibold text-slate-900">TEST123</span> so students can connect instantly.
          </p>
        </div>
      </section>
    </main>

    <div id="feedbackToast" class="feedback-toast fixed bottom-6 left-1/2 z-50 -translate-x-1/2 rounded-full bg-white px-5 py-2 text-sm font-semibold text-slate-900 shadow-xl shadow-slate-300/50">
      Action completed
    </div>

    <!-- Annotate modal -->
    <div id="modal" class="modal fixed inset-0 z-40 hidden flex-col items-center justify-center bg-slate-900/20 px-6 py-10 backdrop-blur-sm">
      <div class="flex w-full max-w-6xl flex-col gap-6">
        <div class="flex flex-col gap-4 rounded-3xl border border-slate-200 bg-white p-6 shadow-xl shadow-brand-200/40">
          <div class="flex flex-col items-start gap-4 md:flex-row md:items-center md:justify-between">
            <div class="flex items-center gap-3 text-left">
              <span class="inline-flex h-12 w-12 items-center justify-center rounded-2xl bg-brand-100 text-2xl">‚úèÔ∏è</span>
              <div>
                <h2 id="modalTitle" class="text-2xl font-semibold text-slate-900">Annotating Student</h2>
                <p class="text-sm text-slate-600">
                  Use undo <kbd class="rounded bg-slate-200 px-1.5 py-0.5 text-[0.65rem] font-semibold uppercase text-slate-800">‚åò</kbd><kbd class="rounded bg-slate-200 px-1.5 py-0.5 text-[0.65rem] font-semibold uppercase text-slate-800">Z</kbd> and redo shortcuts to work even faster.
                </p>
              </div>
            </div>
            <button id="closeModal" class="inline-flex items-center justify-center rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100 focus:outline-none focus-visible:ring-4 focus-visible:ring-brand-200">
              Close
            </button>
          </div>

          <div class="toolbar flex flex-wrap items-center justify-center gap-3 rounded-full border border-slate-200 bg-slate-50 px-6 py-3 shadow-lg shadow-slate-200">
            <div class="flex items-center gap-2" role="group" aria-label="Annotation color">
              <button class="color-btn" style="background:#dc2626" data-color="#dc2626" title="Red"></button>
              <button class="color-btn" style="background:#9333ea" data-color="#9333ea" title="Purple"></button>
              <button class="color-btn" style="background:#14b8a6" data-color="#14b8a6" title="Teal"></button>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <div class="flex items-center gap-2" role="group" aria-label="Annotation tool">
              <button class="tool-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600" data-tool="pen">Pen</button>
              <button class="tool-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600" data-tool="eraser">Eraser</button>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <div class="flex items-center gap-3" aria-label="Brush size">
              <span class="text-xs font-semibold uppercase tracking-wide text-slate-500">Size</span>
              <input type="range" id="brushSize" min="1" max="24" value="4" class="h-1.5 w-28 cursor-pointer appearance-none rounded-full bg-slate-200" />
              <span id="sizeDisplay" class="text-sm font-semibold text-slate-700">4</span>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <div class="flex items-center gap-2" aria-label="Annotation actions">
              <button class="action-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600 disabled:opacity-40" id="undoBtn" title="Undo (‚åò/Ctrl + Z)" disabled>Undo</button>
              <button class="action-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600 disabled:opacity-40" id="redoBtn" title="Redo (‚áß + ‚åò/Ctrl + Z)" disabled>Redo</button>
              <button class="action-btn rounded-full border border-rose-200 bg-rose-500/10 px-4 py-2 text-sm font-semibold text-rose-600" id="clearBtn" title="Clear annotations">Clear</button>
            </div>
            <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
            <button class="stylus-indicator rounded-full border border-slate-200 bg-blue-100 px-4 py-2 text-xs font-semibold uppercase tracking-wide text-blue-800" id="stylusToggle">Stylus mode (pen only)</button>
          </div>
        </div>

        <div class="relative overflow-hidden rounded-3xl border border-slate-200 bg-white p-4 shadow-2xl shadow-slate-200">
          <div class="relative mx-auto max-w-full overflow-hidden rounded-2xl border border-slate-200 shadow-inner">
            <canvas id="bigCanvas" width="800" height="600" class="block h-auto max-h-[70vh] w-full rounded-2xl bg-white"></canvas>
            <canvas id="overlay" width="800" height="600" class="block h-auto max-h-[70vh] w-full rounded-2xl"></canvas>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.4/+esm";

      const SUPABASE_URL = window.SUPABASE_URL;
      const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY;
      if (!SUPABASE_URL || !SUPABASE_ANON_KEY) throw new Error("Missing Supabase credentials.");

      /* ---------- DOM ---------- */
      const studentsDiv = document.getElementById("students");
      const emptyState = document.getElementById("emptyState");
      const modal = document.getElementById("modal");
      const bigCanvas = document.getElementById("bigCanvas");
      const overlay = document.getElementById("overlay");
      const modalTitle = document.getElementById("modalTitle");
      const closeModal = document.getElementById("closeModal");
      const status = document.getElementById("status");
      const sessionInfo = document.getElementById("sessionInfo");
      const sessionCodeDisplay = document.getElementById("sessionCode");
      const studentCount = document.getElementById("studentCount");
      const sessionInput = document.getElementById("sessionInput");
      const feedbackToast = document.getElementById("feedbackToast");
      const activityLabel = document.getElementById("activityLabel");
      const statusLabel = document.getElementById("statusLabel");

      const colorBtns = document.querySelectorAll(".color-btn");
      const toolBtns = document.querySelectorAll(".tool-btn");
      const brushSizeInput = document.getElementById("brushSize");
      const sizeDisplay = document.getElementById("sizeDisplay");
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      const clearBtn = document.getElementById("clearBtn");
      const stylusToggle = document.getElementById("stylusToggle");
      const startSessionBtn = document.getElementById("startSessionBtn");

      /* ---------- Canvas contexts with DPR awareness ---------- */
      const bigCtx = bigCanvas.getContext("2d", { alpha:false, desynchronized:true });
      const overlayCtx = overlay.getContext("2d", { alpha:true, desynchronized:true });
      let overlayDpr = 1, bigDpr = 1;

      function fitCanvasToDisplay(canvas, ctx, maxDpr=3) {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.max(1, Math.min(maxDpr, window.devicePixelRatio || 1));
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        return dpr;
      }

      function resizeBigAndOverlay() {
        bigDpr = fitCanvasToDisplay(bigCanvas, bigCtx);
        overlayDpr = fitCanvasToDisplay(overlay, overlayCtx);
        // redraw snapshot + annotations
        if (currentStudent) {
          const student = students.get(currentStudent);
          if (student) {
            drawStudentIntoBig(student);
            redrawStoredAnnotations(student);
          }
        }
      }

      const bigRO = new ResizeObserver(resizeBigAndOverlay);
      bigRO.observe(bigCanvas);
      window.addEventListener("orientationchange", () => setTimeout(resizeBigAndOverlay, 150));
      window.addEventListener("resize", () => { if (modal.classList.contains("open")) resizeBigAndOverlay(); });

      /* ---------- Status UI ---------- */
      const statusStyles = {
        idle: "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-slate-600 ring-1 ring-slate-200 bg-slate-100",
        connecting: "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-amber-700 ring-1 ring-amber-200 bg-amber-50",
        connected: "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-emerald-700 ring-1 ring-emerald-200 bg-emerald-50",
        error: "inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-sm font-semibold tracking-tight text-rose-700 ring-1 ring-rose-200 bg-rose-50",
      };
      function updateStatus(state, label) {
        status.textContent = label;
        status.className = statusStyles[state] || statusStyles.idle;
        if (statusLabel) statusLabel.textContent = label;
      }
      function logActivity(msg){ if(activityLabel && msg) activityLabel.textContent = msg; }
      function showFeedback(message) {
        if (!message) return;
        logActivity(message);
        if (feedbackToast) {
          feedbackToast.textContent = message;
          feedbackToast.classList.add("show");
          clearTimeout(showFeedback._t);
          showFeedback._t = setTimeout(() => feedbackToast.classList.remove("show"), 1600);
        }
      }

      /* ---------- Supabase ---------- */
      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      let channel = null;
      let sessionCode = null;
      let connectionReady = false;

      function cleanupChannel() {
        if (channel) {
          try { channel.unsubscribe(); } catch {}
          channel = null;
        }
      }

      function handleConnectionError(message, label="Connection error") {
        cleanupChannel();
        connectionReady = false;
        updateStatus("error", label);
        sessionInput.disabled = false;
        startSessionBtn.disabled = false;
        sessionInfo.classList.add("hidden");
        sessionCodeDisplay.textContent = "‚Äî";
        modal.classList.remove("open");
        currentStudent = null;
        resetStudentsUI();
        showFeedback(message);
      }

      function handleChannelStatus(st) {
        if (st === "SUBSCRIBED") {
          connectionReady = true;
          updateStatus("connected", "Connected");
          sessionInfo.classList.remove("hidden");
          sessionCodeDisplay.textContent = sessionCode;
          showFeedback("Session connected");
          return;
        }
        if (st === "CHANNEL_ERROR") handleConnectionError("Connection error. Check Supabase credentials and retry.");
        else if (st === "TIMED_OUT") handleConnectionError("Connection timed out. Tap ‚ÄúStart session‚Äù to retry.", "Connection timed out");
        else if (st === "CLOSED" && connectionReady) handleConnectionError("Connection closed. Tap ‚ÄúStart session‚Äù to reconnect.", "Connection closed");
      }

      async function startSession() {
        sessionCode = sessionInput.value.trim().toUpperCase();
        if (!sessionCode) { alert("Please enter a session code"); return; }
        connectionReady = false;
        resetStudentsUI();
        modal.classList.remove("open");
        currentStudent = null;
        sessionInfo.classList.add("hidden");
        sessionCodeDisplay.textContent = "‚Äî";
        sessionInput.disabled = true;
        startSessionBtn.disabled = true;
        updateStatus("connecting", "Connecting‚Ä¶");
        logActivity("Connecting to session‚Ä¶");

        try {
          cleanupChannel();
          channel = supabase.channel(`minimal-${sessionCode}`, { config: { broadcast: { ack:false } } });

          // student lifecycle listeners
          channel.on("broadcast", { event:"student_ready" }, ({payload}) => { addStudent(payload.username); showFeedback(`${payload.username} joined the session`); });
          channel.on("broadcast", { event:"student_stroke_end" }, ({payload}) => { const s = students.get(payload.username); if (s) { s.strokes.push({ id:payload.stroke.id, color:payload.stroke.color, size:payload.stroke.size, points:payload.stroke.points, isTeacher:false }); redrawStudentCanvas(s); updateStudentPreview(s.username);} });
          channel.on("broadcast", { event:"student_state_change" }, ({payload}) => {
            const s = students.get(payload.username); if (!s) return;
            (payload.added||[]).forEach(stk => { if(!s.strokes.find(x=>x.id===stk.id)) s.strokes.push({ id:stk.id, color:stk.color, size:stk.size, points:stk.points, isTeacher:false }); });
            (payload.removed||[]).forEach(id => { const idx = s.strokes.findIndex(x=>x.id===id); if(idx>=0) s.strokes.splice(idx,1); });
            redrawStudentCanvas(s); updateStudentPreview(s.username);
          });
          channel.on("broadcast", { event:"student_stroke_delete" }, ({payload}) => { const s = students.get(payload.username); if(!s) return; s.strokes = s.strokes.filter(stk => stk.id !== payload.strokeId); redrawStudentCanvas(s); updateStudentPreview(s.username); });
          channel.on("broadcast", { event:"student_clear" }, ({payload}) => { const s = students.get(payload.username); if(!s) return; s.strokes = []; redrawStudentCanvas(s); updateStudentPreview(s.username); });

          channel.subscribe((st) => handleChannelStatus(st));
        } catch (err) {
          console.error("Failed to init channel", err);
          handleConnectionError(err?.message || "Unable to connect to Supabase.");
        }
      }

      // Auto-start for convenience
      window.addEventListener("DOMContentLoaded", () => { sessionInput.value = "TEST123"; setTimeout(startSession, 100); });
      startSessionBtn.addEventListener("click", startSession);
      sessionInput.addEventListener("keypress", (e)=>{ if(e.key==="Enter") startSession(); });

      /* ---------- Student list + previews ---------- */
      const students = new Map();
      function resetStudentsUI() {
        students.clear();
        studentsDiv.innerHTML = "";
        emptyState.classList.remove("hidden");
        studentCount.textContent = "0";
        if (!connectionReady && activityLabel) activityLabel.textContent = "Waiting for session updates";
      }

      function addStudent(username) {
        if (students.has(username)) return;
        emptyState.classList.add("hidden");

        // main student canvas (offscreen)
        const canvas = document.createElement("canvas");
        canvas.width = 800; canvas.height = 600;
        const ctx = canvas.getContext("2d", { alpha:false });
        ctx.fillStyle="#fff"; ctx.fillRect(0,0,800,600); ctx.lineCap="round"; ctx.lineJoin="round";

        students.set(username, {
          username, canvas, ctx, strokes: [],
          teacherAnnotations: [],
          currentAnnotation: null,
          annotationHistory: [],
          annotationHistoryStep: -1,
        });

        // card UI
        const card = document.createElement("div");
        card.className = "flex flex-col gap-4 rounded-3xl border border-slate-200 bg-white p-5 shadow-xl shadow-slate-200";
        card.innerHTML = `
          <div class="flex items-center justify-between gap-3">
            <div class="flex items-center gap-3">
              <span class="inline-flex h-10 w-10 items-center justify-center rounded-2xl bg-emerald-100 text-xl">üë©‚Äçüéì</span>
              <h3 class="text-lg font-semibold text-slate-900">${username}</h3>
            </div>
            <button data-username="${username}" class="annotate-btn inline-flex items-center gap-2 rounded-full bg-brand-600 px-4 py-2 text-sm font-semibold text-white shadow-md shadow-brand-700/30 transition hover:bg-brand-500" title="Open canvas">
              Annotate <span aria-hidden="true">‚Üí</span>
            </button>
          </div>
          <div class="overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-inner">
            <canvas width="800" height="600" class="block h-full w-full"></canvas>
          </div>
        `;
        card.querySelector(".annotate-btn").addEventListener("click", () => annotate(username));
        const previewCtx = card.querySelector("canvas").getContext("2d");
        previewCtx.fillStyle="#fff"; previewCtx.fillRect(0,0,800,600);
        studentsDiv.appendChild(card);
        studentCount.textContent = students.size;
      }

      function drawStroke(ctx, stroke) {
        if (!stroke?.points?.length) return;
        ctx.globalCompositeOperation = "source-over";

        if (stroke.points.length === 1) {
          const p = stroke.points[0];
          ctx.beginPath(); ctx.arc(p.x, p.y, stroke.size/2, 0, Math.PI*2);
          ctx.fillStyle = stroke.color; ctx.fill(); return;
        }
        ctx.strokeStyle = stroke.color; ctx.lineWidth = stroke.size;
        ctx.beginPath(); ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i=1;i<stroke.points.length;i++){
          const prev = stroke.points[i-1], cur = stroke.points[i];
          const mx = (prev.x+cur.x)/2, my=(prev.y+cur.y)/2;
          ctx.quadraticCurveTo(prev.x, prev.y, mx, my);
        }
        ctx.stroke();
      }

      function redrawStudentCanvas(student) {
        const ctx = student.ctx;
        ctx.fillStyle="#fff"; ctx.fillRect(0,0,800,600);
        student.strokes.forEach(stk => drawStroke(ctx, stk));
      }

      function updateStudentPreview(username) {
        const student = students.get(username); if(!student) return;
        const card = Array.from(studentsDiv.children).find(c => c.querySelector("h3")?.textContent === username);
        if (!card) return;
        const previewCanvas = card.querySelector("canvas");
        const pctx = previewCanvas.getContext("2d");
        pctx.clearRect(0,0,800,600);
        pctx.drawImage(student.canvas,0,0);

        // draw teacher overlays into preview
        if (student.teacherAnnotations.length) {
          pctx.lineCap="round"; pctx.lineJoin="round";
          student.teacherAnnotations.forEach(a => {
            if (!a.points?.length) return;
            if (a.points.length===1){ const q=a.points[0]; pctx.beginPath(); pctx.arc(q.x,q.y,(a.size||4)/2,0,Math.PI*2); pctx.fillStyle=a.color||"#dc2626"; pctx.fill(); return; }
            pctx.strokeStyle=a.color||"#dc2626"; pctx.lineWidth=a.size||4;
            pctx.beginPath(); pctx.moveTo(a.points[0].x, a.points[0].y);
            for (let i=1;i<a.points.length;i++){ const pv=a.points[i-1], cu=a.points[i]; const mx=(pv.x+cu.x)/2, my=(pv.y+cu.y)/2; pctx.quadraticCurveTo(pv.x,pv.y,mx,my); }
            pctx.stroke();
          });
        }
      }

      /* ---------- Annotate modal ---------- */
      let currentStudent = null;

      function cloneAnnotations(ann=[]) {
        return ann.map(a => ({ ...a, points: a.points ? a.points.map(p=>({x:p.x,y:p.y})) : [] }));
      }

      function syncHistoryToStudent(student){
        student.annotationHistory = cloneAnnotations(student.teacherAnnotationsHistory || []);
        student.annotationHistoryStep = typeof student.annotationHistoryStep === "number" ? student.annotationHistoryStep : -1;
      }

      function drawStudentIntoBig(student){
        bigCtx.fillStyle="#fff"; bigCtx.fillRect(0,0,bigCanvas.width/bigDpr,bigCanvas.height/bigDpr);
        bigCtx.drawImage(student.canvas,0,0,800,600, 0,0, bigCanvas.width/bigDpr, bigCanvas.height/bigDpr);
      }

      window.annotate = function(username){
        currentStudent = username;
        const student = students.get(username); if(!student) return;

        drawStudentIntoBig(student);
        overlayCtx.clearRect(0,0,overlay.width/overlayDpr, overlay.height/overlayDpr);
        redrawStoredAnnotations(student);

        modalTitle.textContent = `Annotating ${username}`;
        modal.classList.add("open");

        // history boot
        if (!student.annotationHistory) student.annotationHistory = [];
        if (student.annotationHistory.length === 0) {
          student.annotationHistory.push(cloneAnnotations(student.teacherAnnotations));
          student.annotationHistoryStep = 0;
        }
        updateAnnotationHistoryButtons();
        resizeBigAndOverlay();
        showFeedback(`Annotating ${username}`);
      };

      closeModal.addEventListener("click", ()=>{ modal.classList.remove("open"); currentStudent=null; });

      function redrawStoredAnnotations(student){
        overlayCtx.globalCompositeOperation = "source-over";
        student.teacherAnnotations.forEach(a=>{
          if(!a.points?.length) return;
          if (a.points.length===1){ const p=a.points[0]; overlayCtx.beginPath(); overlayCtx.arc(p.x,p.y,(a.size||4)/2,0,Math.PI*2); overlayCtx.fillStyle=a.color||"#dc2626"; overlayCtx.fill(); return; }
          overlayCtx.strokeStyle=a.color||"#dc2626"; overlayCtx.lineWidth=a.size||4; overlayCtx.lineCap="round"; overlayCtx.lineJoin="round";
          overlayCtx.beginPath(); overlayCtx.moveTo(a.points[0].x,a.points[0].y);
          for(let i=1;i<a.points.length;i++){ const pv=a.points[i-1], cu=a.points[i]; const mx=(pv.x+cu.x)/2, my=(pv.y+cu.y)/2; overlayCtx.quadraticCurveTo(pv.x,pv.y,mx,my); }
          overlayCtx.stroke();
        });
      }

      /* ---------- Tools / state ---------- */
      let currentColor = "#dc2626";
      let currentTool = "pen";
      let brushSize = 4;
      let stylusOnly = true;

      colorBtns.forEach(btn=>{
        btn.addEventListener("click", ()=>{
          colorBtns.forEach(b=>b.classList.remove("active"));
          btn.classList.add("active");
          currentColor = btn.dataset.color;
          if (currentTool==="eraser"){ currentTool="pen"; updateToolButtons(); }
        });
      });
      colorBtns[0]?.classList.add("active");

      function updateToolButtons(){ toolBtns.forEach(b=>b.classList.toggle("active", b.dataset.tool===currentTool)); }
      toolBtns.forEach(btn=>btn.addEventListener("click", ()=>{ currentTool = btn.dataset.tool; updateToolButtons(); }));
      updateToolButtons();

      brushSizeInput.addEventListener("input", (e)=>{ brushSize = parseInt(e.target.value,10); sizeDisplay.textContent = brushSize; });
      stylusToggle.addEventListener("click", ()=>{ stylusOnly=!stylusOnly; stylusToggle.classList.toggle("bg-blue-100/80", stylusOnly); stylusToggle.classList.toggle("bg-slate-200/60", !stylusOnly); stylusToggle.textContent = stylusOnly? "Stylus mode (pen only)" : "All inputs enabled"; });

      /* ---------- Annotation history ---------- */
      function updateAnnotationHistoryButtons(){
        const s = students.get(currentStudent); if(!s){ undoBtn.disabled=redoBtn.disabled=true; return; }
        const step = s.annotationHistoryStep ?? 0;
        const len  = s.annotationHistory?.length ?? 0;
        undoBtn.disabled = step <= 0;
        redoBtn.disabled = step >= len - 1;
      }
      function getVisibleAnnotationIds(student){ return new Set(student.teacherAnnotations.map(a=>a.id)); }
      function computeAnnotationDiff(oldIds, newIds, student){
        const added=[], removed=[];
        newIds.forEach(id=>{ if(!oldIds.has(id)){ const a=student.teacherAnnotations.find(x=>x.id===id); if(a){ added.push({id:a.id,color:a.color,size:a.size,points:a.points}); } } });
        oldIds.forEach(id=>{ if(!newIds.has(id)) removed.push(id); });
        return { added, removed };
      }

      function restoreAnnotationState(){
        const s = students.get(currentStudent); if(!s) return;
        const step = s.annotationHistoryStep ?? 0;
        const snap = (s.annotationHistory?.[step]) || [];
        s.teacherAnnotations = cloneAnnotations(snap);
        overlayCtx.clearRect(0,0,overlay.width/overlayDpr, overlay.height/overlayDpr);
        redrawStoredAnnotations(s);
        updateStudentPreview(s.username);
        updateAnnotationHistoryButtons();
      }

      function pushHistorySnapshot(s){
        if (!s.annotationHistory) s.annotationHistory=[];
        const step = s.annotationHistoryStep ?? (s.annotationHistory.length - 1);
        if (step < s.annotationHistory.length - 1) s.annotationHistory = s.annotationHistory.slice(0, step + 1);
        s.annotationHistory.push(cloneAnnotations(s.teacherAnnotations));
        s.annotationHistoryStep = s.annotationHistory.length - 1;
        updateAnnotationHistoryButtons();
      }

      function undoAnnotation(){
        const s = students.get(currentStudent); if(!s) return;
        if ((s.annotationHistoryStep ?? 0) <= 0) return;
        const old = getVisibleAnnotationIds(s);
        s.annotationHistoryStep--;
        restoreAnnotationState();
        const diff = computeAnnotationDiff(old, getVisibleAnnotationIds(s), s);
        if ((diff.added.length || diff.removed.length) && channel){
          channel.send({ type:"broadcast", event:"teacher_state_change", payload:{ target:s.username, added:diff.added, removed:diff.removed } });
        }
        showFeedback("Undo annotation");
      }

      function redoAnnotation(){
        const s = students.get(currentStudent); if(!s) return;
        const len = s.annotationHistory?.length ?? 0;
        if ((s.annotationHistoryStep ?? 0) >= len - 1) return;
        const old = getVisibleAnnotationIds(s);
        s.annotationHistoryStep++;
        restoreAnnotationState();
        const diff = computeAnnotationDiff(old, getVisibleAnnotationIds(s), s);
        if ((diff.added.length || diff.removed.length) && channel){
          channel.send({ type:"broadcast", event:"teacher_state_change", payload:{ target:s.username, added:diff.added, removed:diff.removed } });
        }
        showFeedback("Redo annotation");
      }

      function clearAnnotations(){
        const s = students.get(currentStudent); if(!s) return;
        if (!s.teacherAnnotations.length) return;
        s.teacherAnnotations = [];
        overlayCtx.clearRect(0,0,overlay.width/overlayDpr, overlay.height/overlayDpr);
        updateStudentPreview(s.username);
        pushHistorySnapshot(s);
        if (channel) channel.send({ type:"broadcast", event:"teacher_clear", payload:{ target:s.username } });
        showFeedback("Cleared annotations");
      }

      undoBtn.addEventListener("click", undoAnnotation);
      redoBtn.addEventListener("click", redoAnnotation);
      clearBtn.addEventListener("click", clearAnnotations);

      window.addEventListener("keydown", (e)=>{
        if (!modal.classList.contains("open")) return;
        const meta = e.metaKey || e.ctrlKey;
        if (meta && e.key.toLowerCase()==="z"){ e.preventDefault(); e.shiftKey ? redoAnnotation() : undoAnnotation(); }
        else if (meta && e.key.toLowerCase()==="y"){ e.preventDefault(); redoAnnotation(); }
        else if (e.key==="Backspace" && e.shiftKey){ e.preventDefault(); clearAnnotations(); }
      });

      /* ---------- Pencil-safe overlay drawing: coalesced + RAF ---------- */
      let isAnnotating=false, isErasingAnnotation=false;
      let deletedAnnotationIds = new Set();
      let overlayPointerId = null;
      let liveBuffer = []; // display-space buffered points for RAF
      let rafId = null;

      function overlayRect(){ return overlay.getBoundingClientRect(); }
      function toCanvasPoint(ev){
        const r = overlayRect();
        // convert to 800x600 logical space independent of DPR
        return { x: (ev.clientX - r.left) * (800 / r.width), y:(ev.clientY - r.top) * (600 / r.height) };
      }
      function addCoalesced(ev, arr){
        const list = ev.getCoalescedEvents ? ev.getCoalescedEvents() : [ev];
        for (const ce of list) arr.push(toCanvasPoint(ce));
      }
      function scheduleOverlayFlush(){
        if (rafId !== null) return;
        rafId = requestAnimationFrame(()=>{ rafId=null; flushOverlayBuffer(); });
      }
      function flushOverlayBuffer(){
        const s = students.get(currentStudent); if(!s || !s.currentAnnotation) { liveBuffer=[]; return; }
        if (!liveBuffer.length) return;

        overlayCtx.globalCompositeOperation = "source-over";
        overlayCtx.strokeStyle = s.currentAnnotation.color;
        overlayCtx.lineWidth  = s.currentAnnotation.size;
        if (liveBuffer.length===1){
          const p = liveBuffer[0];
          overlayCtx.beginPath(); overlayCtx.arc(p.x,p.y,s.currentAnnotation.size/2,0,Math.PI*2);
          overlayCtx.fillStyle=s.currentAnnotation.color; overlayCtx.fill();
          liveBuffer = liveBuffer.slice(-1);
          return;
        }
        overlayCtx.beginPath();
        let prev = liveBuffer[0];
        overlayCtx.moveTo(prev.x, prev.y);
        for (let i=1;i<liveBuffer.length;i++){
          const cur = liveBuffer[i];
          const mx=(prev.x+cur.x)/2, my=(prev.y+cur.y)/2;
          overlayCtx.quadraticCurveTo(prev.x, prev.y, mx, my);
          prev = cur;
        }
        overlayCtx.stroke();
        liveBuffer = liveBuffer.slice(-2);
      }

      overlay.addEventListener("pointerdown", (e)=>{
        const s = students.get(currentStudent); if(!s) return;
        if (stylusOnly && e.pointerType!=="pen") return;
        e.preventDefault();
        overlayPointerId = e.pointerId;
        overlay.setPointerCapture?.(overlayPointerId);

        const p = toCanvasPoint(e);
        if (currentTool === "eraser"){
          isErasingAnnotation = true; deletedAnnotationIds = new Set();
          eraseAtPoint(s, p);
          return;
        }
        isAnnotating = true;
        s.currentAnnotation = { id: Date.now()+"-"+Math.random().toString(16).slice(2), points:[p], color: currentColor, size: brushSize, isTeacher:true };
        liveBuffer = [p];
        scheduleOverlayFlush();
      });

      overlay.addEventListener("pointermove", (e)=>{
        const s = students.get(currentStudent); if(!s) return;
        if (overlayPointerId !== e.pointerId) return;

        if (isErasingAnnotation){
          e.preventDefault();
          const list = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
          for (const ce of list) eraseAtPoint(s, toCanvasPoint(ce));
          return;
        }
        if (!isAnnotating || !s.currentAnnotation) return;
        e.preventDefault();
        addCoalesced(e, s.currentAnnotation.points);
        addCoalesced(e, liveBuffer);

        // Optional: send a throttled "last point" if you want live previews on student side
        const last = s.currentAnnotation.points[s.currentAnnotation.points.length-1];
        // (Skipping broadcast here to keep noise low)

        scheduleOverlayFlush();
      });

      function finalizeOverlayInteraction(e){
        const s = students.get(currentStudent); if(!s) return;
        if (overlayPointerId !== e.pointerId) return;

        if (isErasingAnnotation){
          isErasingAnnotation = false;
          overlay.releasePointerCapture?.(overlayPointerId);
          overlayPointerId = null;
          if (deletedAnnotationIds.size){
            pushHistorySnapshot(s);
            const diff = { added:[], removed:Array.from(deletedAnnotationIds) };
            if (channel) channel.send({ type:"broadcast", event:"teacher_state_change", payload:{ target:s.username, ...diff } });
            showFeedback(`Removed ${deletedAnnotationIds.size} annotation${deletedAnnotationIds.size>1?"s":""}`);
          }
          deletedAnnotationIds.clear();
          return;
        }

        if (!isAnnotating || !s.currentAnnotation){
          overlay.releasePointerCapture?.(overlayPointerId);
          overlayPointerId = null; return;
        }

        if (rafId) cancelAnimationFrame(rafId);
        flushOverlayBuffer();

        // single dot support
        if (s.currentAnnotation.points.length===1){
          const q = s.currentAnnotation.points[0];
          overlayCtx.beginPath(); overlayCtx.arc(q.x,q.y,s.currentAnnotation.size/2,0,Math.PI*2);
          overlayCtx.fillStyle=s.currentAnnotation.color; overlayCtx.fill();
        }

        s.teacherAnnotations.push(s.currentAnnotation);
        updateStudentPreview(s.username);
        pushHistorySnapshot(s);

        channel?.send({ type:"broadcast", event:"teacher_stroke_end", payload:{ target:s.username, stroke:{ id:s.currentAnnotation.id, color:s.currentAnnotation.color, size:s.currentAnnotation.size, points:s.currentAnnotation.points } } });

        s.currentAnnotation = null;
        isAnnotating=false;
        liveBuffer=[];
        overlay.releasePointerCapture?.(overlayPointerId);
        overlayPointerId=null;
        showFeedback("Annotation added");
      }

      overlay.addEventListener("pointerup", finalizeOverlayInteraction);
      overlay.addEventListener("pointercancel", finalizeOverlayInteraction);
      overlay.addEventListener("pointerleave", (e)=>{
        // treat as finalize to avoid dangling strokes
        finalizeOverlayInteraction(e);
      });

      function eraseAtPoint(student, p){
        const eraserRadius = Math.max(30, brushSize*3);
        let changed=false;
        for (let i=student.teacherAnnotations.length-1;i>=0;i--){
          const a = student.teacherAnnotations[i]; if (!a?.points?.length) continue;
          if (deletedAnnotationIds.has(a.id)) continue;

          let hit=false;
          for (let j=0;j<a.points.length;j++){
            const pt=a.points[j];
            const d = Math.hypot(pt.x - p.x, pt.y - p.y);
            if (d < eraserRadius + (a.size||4)/2){ hit=true; break; }
            if (j>0){
              const pv=a.points[j-1];
              const hitSeg = distToSegmentSquared(p.x,p.y,pv.x,pv.y,pt.x,pt.y) < (eraserRadius + (a.size||4)/2)**2;
              if (hitSeg){ hit=true; break; }
            }
          }
          if (hit){
            deletedAnnotationIds.add(a.id);
            student.teacherAnnotations.splice(i,1);
            channel?.send({ type:"broadcast", event:"teacher_stroke_delete", payload:{ target:student.username, strokeId:a.id } });
            changed=true;
          }
        }
        if (changed){
          overlayCtx.clearRect(0,0,overlay.width/overlayDpr, overlay.height/overlayDpr);
          redrawStoredAnnotations(student);
          updateStudentPreview(student.username);
        }
      }

      function distToSegmentSquared(px,py,x1,y1,x2,y2){
        const dx=x2-x1, dy=y2-y1, len2=dx*dx+dy*dy;
        if(!len2) return (px-x1)**2+(py-y1)**2;
        let t=((px-x1)*dx + (py-y1)*dy)/len2; t=Math.max(0,Math.min(1,t));
        const qx=x1+t*dx, qy=y1+t*dy;
        return (px-qx)**2+(py-qy)**2;
      }
    </script>
  </body>
</html>
