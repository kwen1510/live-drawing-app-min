<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Student Canvas — 800×600</title>
<style>
  :root{
    --bg:#0b1020; --card:#ffffff; --muted:#f1f5f9; --ink:#111827;
    --blue:#2563eb; --green:#16a34a; --red:#ef4444; --accent:#0ea5e9;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    background: linear-gradient(135deg,#0f172a 0%, #1e293b 60%, #0b1020 100%);
    color:#0f172a; padding:24px; display:flex; min-height:100svh; align-items:center; justify-content:center;
  }
  .wrap{
    width:min(100%, 980px);
  }
  .topbar{
    display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; color:#e2e8f0;
  }
  .topbar .status{
    display:inline-flex; gap:8px; align-items:center; font-size:14px; background: #0b1222; padding:6px 10px; border-radius:999px;
    border:1px solid #1f2a44;
  }
  .dot{width:8px;height:8px;border-radius:999px;background:#22c55e;box-shadow:0 0 0 3px rgb(34 197 94 / 15%)}
  .card{
    background:var(--card); border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.35);
    padding:14px; border:1px solid #e5e7eb;
  }
  .toolbar{
    display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px;
  }
  .group{display:flex; align-items:center; gap:6px; background:var(--muted); border-radius:12px; padding:6px}
  .btn{
    appearance:none; border:0; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer;
    box-shadow:0 1px 0 rgba(0,0,0,.06) inset; border:1px solid #e5e7eb; font-weight:600;
  }
  .btn[disabled]{opacity:.45; cursor:not-allowed}
  .btn.is-active{outline:2px solid var(--accent); outline-offset:0}
  .swatch{
    width:28px;height:28px;border-radius:999px;border:2px solid #e2e8f0; box-shadow:0 1px 0 rgba(0,0,0,.06) inset; cursor:pointer;
  }
  .swatch.is-active{outline:2px solid #0ea5e9; outline-offset:2px}
  .slider{
    display:flex; align-items:center; gap:8px; padding:0 6px;
  }
  input[type="range"]{width:140px}
  .preview-dot{width:20px;height:20px;border-radius:999px;background:var(--ink); border:1px solid #cbd5e1}
  .canvas-wrap{
    display:flex; align-items:center; justify-content:center; background:#0b1222; border-radius:12px; padding:16px;
    border:1px solid #1e2a49;
  }
  canvas{
    display:block; background:#ffffff; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25);
    touch-action:none; /* important for iPad drawing */
  }
  .pill{
    padding:6px 10px; border-radius:999px; font-weight:600; border:1px solid #e5e7eb; background:#fff;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 style="margin:0; font-size:18px; font-weight:700; letter-spacing:.2px; color:#e2e8f0">Student Canvas</h1>
      <span class="status"><span class="dot" aria-hidden="true"></span><span>Ready</span></span>
    </div>

    <div class="card">
      <div class="toolbar" role="toolbar" aria-label="Drawing controls">
        <!-- Colors -->
        <div class="group" role="group" aria-label="Ink colour">
          <button class="swatch is-active" data-color="#111827" title="Black" style="background:#111827"></button>
          <button class="swatch" data-color="#2563eb" title="Blue" style="background:#2563eb"></button>
          <button class="swatch" data-color="#16a34a" title="Green" style="background:#16a34a"></button>
          <button class="swatch" data-color="#ef4444" title="Red" style="background:#ef4444"></button>
        </div>

        <!-- Tools -->
        <div class="group" role="group" aria-label="Tool">
          <button class="btn is-active" data-tool="pen" title="Pen">Pen</button>
          <button class="btn" data-tool="eraser" title="Eraser">Eraser</button>
        </div>

        <!-- Brush size -->
        <div class="group slider" role="group" aria-label="Brush size">
          <label for="brush" class="pill">Size</label>
          <input id="brush" type="range" min="1" max="12" value="2.2" step="0.2" />
          <div class="preview-dot" id="sizePreview" title="Preview"></div>
          <span id="sizeLabel" class="pill">2.2 px</span>
        </div>

        <!-- History -->
        <div class="group" role="group" aria-label="History">
          <button class="btn" id="undoBtn" disabled>Undo</button>
          <button class="btn" id="redoBtn" disabled>Redo</button>
          <button class="btn" id="clearBtn">Clear</button>
        </div>

        <!-- Stylus mode -->
        <div class="group" role="group" aria-label="Input">
          <button class="btn" id="stylusBtn" aria-pressed="true">Stylus-only</button>
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="pad" width="800" height="600" aria-label="Drawing canvas (800 by 600)"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // --- Config & State ---
  const DEFAULT_COLOR = '#111827';
  const DEFAULT_SIZE = 2.2;
  const MIN_SIZE = 1;
  const MAX_SIZE = 12;
  const ERASER_MULT = 5.2;

  const pad = document.getElementById('pad');
  const ctx = pad.getContext('2d', { alpha:false, desynchronized:true });

  const colorBtns = [...document.querySelectorAll('[data-color]')];
  const toolBtns = [...document.querySelectorAll('[data-tool]')];
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const stylusBtn = document.getElementById('stylusBtn');
  const sizeSlider = document.getElementById('brush');
  const sizeLabel = document.getElementById('sizeLabel');
  const sizePreview = document.getElementById('sizePreview');

  const tool = {
    color: DEFAULT_COLOR,
    size: DEFAULT_SIZE,
    mode: 'pen', // 'pen' | 'eraser'
    stylusOnly: true
  };

  const state = {
    drawing:false,
    pointerId:null,
    buffer:[],
    history:[],       // current stroke points (display coords)
    raf:null,
    paths:[],         // { color, width, erase, points:[{x,y}] }
    undoStack:[],
    redoStack:[]
  };

  // --- Helpers ---
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
  function setInk(color){ tool.color = color; updateColorUI(); updateSizeUI(); }
  function setMode(mode){ tool.mode = mode; updateToolUI(); updateSizeUI(); }
  function setSize(px){ tool.size = clamp(+px||DEFAULT_SIZE, MIN_SIZE, MAX_SIZE); updateSizeUI(); }
  function eraserSize(){ return clamp(tool.size * ERASER_MULT, MIN_SIZE*ERASER_MULT, MAX_SIZE*ERASER_MULT); }
  function baseWidth(){ return tool.mode==='eraser' ? eraserSize() : tool.size; }

  function updateColorUI(){
    colorBtns.forEach(b=>{
      const active = b.dataset.color === tool.color && tool.mode!=='eraser';
      b.classList.toggle('is-active', active);
    });
  }
  function updateToolUI(){
    toolBtns.forEach(b => b.classList.toggle('is-active', b.dataset.tool===tool.mode));
  }
  function updateSizeUI(){
    sizeSlider.value = tool.mode==='eraser' ? (tool.size) : tool.size;
    sizeLabel.textContent = `${tool.size.toFixed(1)} px`;
    const previewSize = Math.round((tool.size - MIN_SIZE) / (MAX_SIZE - MIN_SIZE) * 28 + 10);
    sizePreview.style.width = previewSize + 'px';
    sizePreview.style.height = previewSize + 'px';
    sizePreview.style.background = tool.mode==='eraser' ? '#ffffff' : tool.color;
  }
  function updateHistoryUI(){
    undoBtn.disabled = state.undoStack.length===0;
    redoBtn.disabled = state.redoStack.length===0;
  }

  // --- Canvas background ---
  function resetCanvas(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0, pad.width, pad.height);
  }
  resetCanvas();

  // --- Rendering ---
  function drawDot(pt, width, color, erase){
    const r = Math.max(0.45*width, Math.min(0.8*width, 0.5*width));
    ctx.save();
    ctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
    ctx.beginPath(); ctx.arc(pt.x, pt.y, r, 0, Math.PI*2);
    ctx.fillStyle = erase ? '#000' : color;
    ctx.fill(); ctx.restore();
  }

  function strokePath(points, width, color, erase){
    if(points.length===1){ drawDot(points[0], width, color, erase); return; }
    ctx.save();
    ctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
    ctx.strokeStyle = erase ? '#000' : color;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    let prev = points[0];
    ctx.moveTo(prev.x, prev.y);
    for(let i=1;i<points.length;i++){
      const cur = points[i];
      const mid = { x:(prev.x+cur.x)/2, y:(prev.y+cur.y)/2 };
      ctx.lineWidth = width;
      ctx.quadraticCurveTo(prev.x, prev.y, mid.x, mid.y);
      ctx.stroke();
      prev = cur;
    }
    // end cap
    drawDot(points[points.length-1], width, color, erase);
    ctx.restore();
  }

  function renderAll(){
    resetCanvas();
    state.paths.forEach(p => strokePath(p.points, p.width, p.color, p.erase));
  }

  // --- Hit testing for eraser (erase whole stroke you touch) ---
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function distToSeg(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y, wx=p.x-a.x, wy=p.y-a.y;
    const c = vx*vx+vy*vy; if(!c) return dist(p,a);
    let t=(wx*vx+wy*vy)/c; t=clamp(t,0,1);
    const cx=a.x+t*vx, cy=a.y+t*vy;
    return Math.hypot(p.x-cx,p.y-cy);
  }
  function hitStrokeIndex(pt){
    for(let i=state.paths.length-1;i>=0;i--){
      const path=state.paths[i]; const pts=path.points; if(!pts.length) continue;
      const w = path.width; const pad = Math.max(w*0.6, 6);
      if(pts.length===1){ if(dist(pt, pts[0]) <= Math.max(0.5*w, 6)+pad) return i; continue; }
      for(let j=1;j<pts.length;j++){
        const d = distToSeg(pt, pts[j-1], pts[j]);
        if(d <= Math.max(0.6*w, 6)+pad) return i;
      }
    }
    return -1;
  }

  // --- Pointer utils ---
  function supportedPointer(e){
    const t = (e.pointerType||'').toLowerCase();
    if(tool.stylusOnly) return t==='' || t==='pen' || t==='mouse';
    return t==='' || t==='pen' || t==='mouse' || t==='touch';
  }
  function canvasPoint(e){
    const r = pad.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // --- Drawing lifecycle ---
  function startStroke(e){
    if(!supportedPointer(e)) return;
    e.preventDefault();
    if(typeof e.pointerId==='number' && pad.setPointerCapture){
      try{ pad.setPointerCapture(e.pointerId);}catch{}
    }
    state.drawing = true;
    state.pointerId = e.pointerId ?? null;
    state.buffer = [];
    state.history = [];
    const pt = canvasPoint(e);
    if(tool.mode==='eraser'){
      // begin erase session
      eraseAt(pt, true);
      return;
    }
    state.history.push(pt);
    scheduleDraw(false);
  }

  function moveStroke(e){
    if(!state.drawing) return;
    if(state.pointerId!=null && e.pointerId!=null && e.pointerId!==state.pointerId) return;
    if(!supportedPointer(e)) return;
    e.preventDefault();
    const pt = canvasPoint(e);
    if(tool.mode==='eraser'){
      eraseAt(pt, false);
      return;
    }
    state.history.push(pt);
    scheduleDraw(false);
  }

  function endStroke(e){
    if(!state.drawing) return;
    if(state.pointerId!=null && e.pointerId!=null && e.pointerId!==state.pointerId) return;
    e.preventDefault();
    if(typeof e.pointerId==='number' && pad.releasePointerCapture){
      try{ pad.releasePointerCapture(e.pointerId);}catch{}
    }
    if(tool.mode!=='eraser' && state.history.length){
      if(state.raf){ cancelAnimationFrame(state.raf); state.raf=null; }
      strokePath(state.history, baseWidth(), tool.color, false);
      state.paths.push({ color: tool.color, width: baseWidth(), erase:false, points:[...state.history] });
      state.undoStack.push({ type:'draw' });
      state.redoStack.length=0;
      updateHistoryUI();
    }
    state.drawing=false; state.pointerId=null; state.history=[];
  }
  function cancelStroke(e){
    if(!state.drawing) return;
    e.preventDefault();
    state.drawing=false; state.pointerId=null; state.history=[];
    if(state.raf){ cancelAnimationFrame(state.raf); state.raf=null; }
  }

  function eraseAt(pt, first){
    if(first){
      // begin a grouped erase action
      state._eraseBatch = [];
    }
    const idx = hitStrokeIndex(pt);
    if(idx!==-1){
      const [removed] = state.paths.splice(idx,1);
      state._eraseBatch.push({ path: removed, index: idx });
      renderAll();
    }
  }
  function finishErase(){
    const batch = state._eraseBatch || [];
    if(batch.length){
      state.undoStack.push({ type:'erase', entries: batch });
      state.redoStack.length=0; updateHistoryUI();
    }
    state._eraseBatch = null;
  }

  // Smooth rendering via RAF
  function scheduleDraw(finalFlush){
    if(state.raf) return;
    state.raf = requestAnimationFrame(()=>{
      state.raf=null;
      if(!state.history.length) return;
      const pts = state.history;
      const w = baseWidth(); const color = tool.color;
      // incremental draw:
      if(pts.length===1){
        drawDot(pts[0], w, color, false);
      }else{
        const seg = pts.slice(-2);
        strokePath(seg, w, color, false);
      }
      if(finalFlush){ /* not used here */ }
    });
  }

  // --- History actions ---
  undoBtn.addEventListener('click', () => {
    if(!state.undoStack.length) return;
    const action = state.undoStack.pop();
    if(action.type==='draw'){
      const removed = state.paths.pop();
      if(removed) state.redoStack.push({ type:'draw', path: removed });
    }else if(action.type==='erase'){
      // put back removed strokes in original positions
      const entries = action.entries || [];
      for(let i=entries.length-1;i>=0;i--){
        const { path, index } = entries[i];
        state.paths.splice(index, 0, path);
      }
      state.redoStack.push({ type:'erase', entries });
    }
    renderAll(); updateHistoryUI();
  });

  redoBtn.addEventListener('click', () => {
    if(!state.redoStack.length) return;
    const action = state.redoStack.pop();
    if(action.type==='draw'){
      state.paths.push(action.path);
      state.undoStack.push({ type:'draw' });
    }else if(action.type==='erase'){
      const performed=[];
      (action.entries||[]).forEach(({ path, index })=>{
        const i = state.paths.indexOf(path);
        if(i!==-1){
          const [rm] = state.paths.splice(i,1);
          performed.push({ path: rm, index: i });
        }else if(index>=0 && index<state.paths.length){
          const [rm] = state.paths.splice(index,1);
          performed.push({ path: rm, index });
        }
      });
      if(performed.length) state.undoStack.push({ type:'erase', entries: performed });
    }
    renderAll(); updateHistoryUI();
  });

  clearBtn.addEventListener('click', () => {
    state.paths.length=0; state.undoStack.length=0; state.redoStack.length=0;
    renderAll(); updateHistoryUI();
  });

  // --- UI wiring ---
  colorBtns.forEach(b=>{
    b.addEventListener('click', ()=>{ setInk(b.dataset.color); setMode('pen'); });
  });
  toolBtns.forEach(b=>{
    b.addEventListener('click', ()=> setMode(b.dataset.tool));
  });
  sizeSlider.addEventListener('input', e => setSize(e.target.value));
  stylusBtn.addEventListener('click', ()=>{
    tool.stylusOnly = !tool.stylusOnly;
    stylusBtn.setAttribute('aria-pressed', String(tool.stylusOnly));
    stylusBtn.textContent = tool.stylusOnly ? 'Stylus-only' : 'Pen/Touch';
  });

  // --- Pointer events ---
  pad.addEventListener('pointerdown', (e)=>{ startStroke(e); });
  pad.addEventListener('pointermove', (e)=>{ moveStroke(e); });
  pad.addEventListener('pointerup',   (e)=>{ if(tool.mode==='eraser') finishErase(); endStroke(e); });
  pad.addEventListener('pointercancel',(e)=>{ if(tool.mode==='eraser') finishErase(); cancelStroke(e); });
  pad.addEventListener('pointerleave', (e)=>{ if(tool.mode==='eraser') finishErase(); cancelStroke(e); });

  // prevent page scrolling/zoom gestures interfering on iPad
  ['touchstart','touchmove','gesturestart'].forEach(ev=>{
    pad.addEventListener(ev, e=>{ e.preventDefault(); }, { passive:false });
  });

  // init UI
  updateColorUI(); updateToolUI(); updateSizeUI(); updateHistoryUI();
})();
</script>
</body>
</html>
