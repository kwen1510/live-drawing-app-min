<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Student Canvas — 800×600</title>
<style>
  :root{
    --card:#ffffff; --muted:#f1f5f9; --ink:#111827;
    --blue:#2563eb; --green:#16a34a; --red:#ef4444; --accent:#0ea5e9;
    --chrome:#0b1222; --border:#1e2a49;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    min-height:100svh; /* iPad-friendly */
    background: linear-gradient(135deg,#0f172a 0%, #1e293b 60%, #0b1020 100%);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
    color:#0f172a;
    padding:16px;
    overflow:hidden; /* no scroll */
  }

  .wrap{
    height:calc(100svh - 32px); /* fill without overflow */
    display:flex; flex-direction:column; gap:10px;
    max-width: 1220px; margin:0 auto;
  }

  .topbar{
    display:flex; align-items:center; justify-content:space-between;
    color:#e2e8f0; min-height:36px;
  }
  .status{
    display:inline-flex; gap:8px; align-items:center; font-size:14px;
    background: #0b1222; padding:6px 10px; border-radius:999px;
    border:1px solid #1f2a44;
  }
  .dot{width:8px;height:8px;border-radius:999px;background:#22c55e;box-shadow:0 0 0 3px rgb(34 197 94 / 15%)}

  .card{
    flex:1; display:flex; flex-direction:column; gap:10px;
    background:var(--card); border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.35);
    border:1px solid #e5e7eb; padding:12px; overflow:hidden;
  }

  .toolbar{
    display:flex; flex-wrap:wrap; gap:8px; align-items:center;
  }
  .group{display:flex; align-items:center; gap:6px; background:var(--muted); border-radius:12px; padding:6px}
  .btn{
    appearance:none; border:1px solid #e5e7eb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer;
    box-shadow:0 1px 0 rgba(0,0,0,.06) inset; font-weight:600;
  }
  .btn[disabled]{opacity:.45; cursor:not-allowed}
  .btn.is-active{outline:2px solid var(--accent); outline-offset:0}
  .swatch{
    width:28px;height:28px;border-radius:999px;border:2px solid #e2e8f0; box-shadow:0 1px 0 rgba(0,0,0,.06) inset; cursor:pointer;
  }
  .swatch.is-active{outline:2px solid #0ea5e9; outline-offset:2px}
  .slider{display:flex; align-items:center; gap:8px; padding:0 6px;}
  input[type="range"]{width:140px}
  .preview-dot{width:20px;height:20px;border-radius:999px;background:var(--ink); border:1px solid #cbd5e1}
  .pill{padding:6px 10px; border-radius:999px; font-weight:600; border:1px solid #e5e7eb; background:#fff}

  .stage{
    /* This region flexes to fill remaining height; we then fit the canvas inside it */
    flex:1; min-height:0; /* important to avoid overflow */
    display:flex; align-items:center; justify-content:center;
    background:var(--chrome); border:1px solid var(--border);
    border-radius:12px; padding:12px;
    overflow:hidden;
  }

  canvas{
    display:block; background:#ffffff; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25);
    /* We scale with CSS; pointer mapping compensates for size */
    touch-action:none; /* crucial for iPad drawing */
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 style="margin:0; font-size:18px; font-weight:700; letter-spacing:.2px;">Student Canvas</h1>
      <span class="status"><span class="dot" aria-hidden="true"></span><span>Ready</span></span>
    </div>

    <div class="card">
      <div class="toolbar" role="toolbar" aria-label="Drawing controls">
        <!-- Colors -->
        <div class="group" role="group" aria-label="Ink colour">
          <button class="swatch is-active" data-color="#111827" title="Black" style="background:#111827"></button>
          <button class="swatch" data-color="#2563eb" title="Blue" style="background:#2563eb"></button>
          <button class="swatch" data-color="#16a34a" title="Green" style="background:#16a34a"></button>
          <button class="swatch" data-color="#ef4444" title="Red" style="background:#ef4444"></button>
        </div>

        <!-- Tools -->
        <div class="group" role="group" aria-label="Tool">
          <button class="btn is-active" data-tool="pen" title="Pen">Pen</button>
          <button class="btn" data-tool="eraser" title="Eraser">Eraser</button>
        </div>

        <!-- Brush size -->
        <div class="group slider" role="group" aria-label="Brush size">
          <label for="brush" class="pill">Size</label>
          <input id="brush" type="range" min="1" max="12" value="2.2" step="0.2" />
          <div class="preview-dot" id="sizePreview" title="Preview"></div>
          <span id="sizeLabel" class="pill">2.2 px</span>
        </div>

        <!-- History -->
        <div class="group" role="group" aria-label="History">
          <button class="btn" id="undoBtn" disabled>Undo</button>
          <button class="btn" id="redoBtn" disabled>Redo</button>
          <button class="btn" id="clearBtn">Clear</button>
        </div>

        <!-- Stylus mode -->
        <div class="group" role="group" aria-label="Input">
          <button class="btn" id="stylusBtn" aria-pressed="true">Stylus-only</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="pad" width="800" height="600" aria-label="Drawing canvas (800 by 600)"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const CANVAS_W = 800, CANVAS_H = 600;
  const DEFAULT_COLOR = '#111827';
  const DEFAULT_SIZE = 2.2;
  const MIN_SIZE = 1, MAX_SIZE = 12;
  const ERASER_MULT = 5.2;

  // ===== Elements =====
  const stage = document.getElementById('stage');
  const pad = document.getElementById('pad');
  const ctx = pad.getContext('2d', { alpha:false, desynchronized:true });

  const colorBtns = [...document.querySelectorAll('[data-color]')];
  const toolBtns = [...document.querySelectorAll('[data-tool]')];
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const stylusBtn = document.getElementById('stylusBtn');
  const sizeSlider = document.getElementById('brush');
  const sizeLabel = document.getElementById('sizeLabel');
  const sizePreview = document.getElementById('sizePreview');

  // ===== State =====
  const tool = { color: DEFAULT_COLOR, size: DEFAULT_SIZE, mode: 'pen', stylusOnly: true };

  const state = {
    drawing:false,
    pointerId:null,
    currentPath:null, // { color,width,erase,points:[] }
    paths:[],         // committed paths
    undoStack:[],     // actions: {type:'draw'|'erase'|'clear', path?, entries?, prev?}
    redoStack:[],
    eraseBatch:null   // temp collection for grouped erases
  };

  // ===== Layout: fit canvas (no scrolling, any orientation) =====
  function fitCanvasToStage(){
    // Available inner size of stage minus its paddings
    const cs = getComputedStyle(stage);
    const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
    const availW = Math.max(0, stage.clientWidth - padX);
    const availH = Math.max(0, stage.clientHeight - padY);

    const scale = Math.min(availW / CANVAS_W, availH / CANVAS_H, 1); // never upscale above 1
    pad.style.width  = (CANVAS_W * scale) + 'px';
    pad.style.height = (CANVAS_H * scale) + 'px';
  }

  // ===== Utils =====
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
  function eraserSize(){ return clamp(tool.size * ERASER_MULT, MIN_SIZE*ERASER_MULT, MAX_SIZE*ERASER_MULT); }
  function baseWidth(){ return tool.mode==='eraser' ? eraserSize() : tool.size; }

  function resetCanvas(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0, CANVAS_W, CANVAS_H);
  }

  function updateColorUI(){
    colorBtns.forEach(b=>{
      const active = b.dataset.color === tool.color && tool.mode!=='eraser';
      b.classList.toggle('is-active', active);
    });
  }
  function updateToolUI(){
    toolBtns.forEach(b => b.classList.toggle('is-active', b.dataset.tool===tool.mode));
  }
  function updateSizeUI(){
    sizeSlider.value = tool.size;
    sizeLabel.textContent = `${(+tool.size).toFixed(1)} px`;
    const previewSize = Math.round((tool.size - MIN_SIZE) / (MAX_SIZE - MIN_SIZE) * 28 + 10);
    sizePreview.style.width = previewSize + 'px';
    sizePreview.style.height = previewSize + 'px';
    sizePreview.style.background = tool.mode==='eraser' ? '#ffffff' : tool.color;
  }
  function updateHistoryUI(){
    undoBtn.disabled = state.undoStack.length===0;
    redoBtn.disabled = state.redoStack.length===0;
  }

  // Precise mapping from client coords to internal (800×600) coords, even if CSS scaled
  function canvasPoint(e){
    const r = pad.getBoundingClientRect();
    const x = (e.clientX - r.left) * (pad.width  / r.width);
    const y = (e.clientY - r.top)  * (pad.height / r.height);
    return { x, y };
  }

  function supportedPointer(e){
    const t = (e.pointerType||'').toLowerCase();
    if(tool.stylusOnly) return t==='' || t==='pen' || t==='mouse';
    return t==='' || t==='pen' || t==='mouse' || t==='touch';
  }

  // ===== Rendering (live & committed) =====
  function drawDot(pt, width, color, erase){
    const r = Math.max(0.45*width, Math.min(0.8*width, 0.5*width));
    ctx.save();
    ctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
    ctx.beginPath(); ctx.arc(pt.x, pt.y, r, 0, Math.PI*2);
    ctx.fillStyle = erase ? '#000' : color;
    ctx.fill(); ctx.restore();
  }

  function strokeLiveBegin(pt, width, color, erase){
    ctx.save();
    ctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
    ctx.strokeStyle = erase ? '#000' : color;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(pt.x, pt.y);
  }
  function strokeLiveTo(pt){ ctx.lineTo(pt.x, pt.y); ctx.stroke(); }
  function strokeLiveEnd(){ ctx.restore(); }

  function renderAll(){
    resetCanvas();
    state.paths.forEach(p => {
      if(!p.points.length){ return; }
      if(p.points.length===1){ drawDot(p.points[0], p.width, p.color, p.erase); return; }
      // replay path
      strokeLiveBegin(p.points[0], p.width, p.color, p.erase);
      for(let i=1;i<p.points.length;i++) strokeLiveTo(p.points[i]);
      strokeLiveEnd();
    });
  }

  // ===== Hit testing for eraser (erase whole stroke you touch) =====
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function distToSeg(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y, wx=p.x-a.x, wy=p.y-a.y;
    const c = vx*vx+vy*vy; if(!c) return dist(p,a);
    let t=(wx*vx+wy*vy)/c; t=clamp(t,0,1);
    const cx=a.x+t*vx, cy=a.y+t*vy;
    return Math.hypot(p.x-cx,p.y-cy);
  }
  function hitStrokeIndex(pt){
    for(let i=state.paths.length-1;i>=0;i--){
      const path=state.paths[i]; const pts=path.points; if(!pts.length) continue;
      const w = path.width; const pad = Math.max(w*0.6, 6);
      if(pts.length===1){ if(dist(pt, pts[0]) <= Math.max(0.5*w, 6)+pad) return i; continue; }
      for(let j=1;j<pts.length;j++){
        const d = distToSeg(pt, pts[j-1], pts[j]);
        if(d <= Math.max(0.6*w, 6)+pad) return i;
      }
    }
    return -1;
  }

  // ===== Drawing lifecycle =====
  function startStroke(e){
    if(!supportedPointer(e)) return;
    e.preventDefault();
    if(typeof e.pointerId==='number' && pad.setPointerCapture){
      try{ pad.setPointerCapture(e.pointerId);}catch{}
    }
    const pt = canvasPoint(e);

    if(tool.mode==='eraser'){
      state.eraseBatch = [];
      eraseAt(pt); // immediate erase if hitting something
      state.drawing = true;
      state.pointerId = e.pointerId ?? null;
      return;
    }

    // Begin a new ink stroke
    const p = { color: tool.color, width: baseWidth(), erase:false, points:[pt] };
    state.currentPath = p;
    strokeLiveBegin(pt, p.width, p.color, false);

    state.drawing = true;
    state.pointerId = e.pointerId ?? null;
  }

  function moveStroke(e){
    if(!state.drawing) return;
    if(state.pointerId!=null && e.pointerId!=null && e.pointerId!==state.pointerId) return;
    if(!supportedPointer(e)) return;
    e.preventDefault();

    const pt = canvasPoint(e);

    if(tool.mode==='eraser'){
      eraseAt(pt);
      return;
    }

    // Continue live ink stroke
    state.currentPath.points.push(pt);
    strokeLiveTo(pt);
  }

  function endStroke(e){
    if(!state.drawing) return;
    if(state.pointerId!=null && e.pointerId!=null && e.pointerId!==state.pointerId) return;
    e.preventDefault();

    if(typeof e.pointerId==='number' && pad.releasePointerCapture){
      try{ pad.releasePointerCapture(e.pointerId);}catch{}
    }

    if(tool.mode==='eraser'){
      finishErase();
      state.drawing=false; state.pointerId=null; return;
    }

    // Finalize ink stroke
    const p = state.currentPath;
    if(p){
      if(p.points.length===1){
        drawDot(p.points[0], p.width, p.color, false); // ensure dot visible
      }
      strokeLiveEnd();
      state.paths.push(p);
      state.undoStack.push({ type:'draw', path: p });
      state.redoStack.length=0;
      updateHistoryUI();
      state.currentPath = null;
    }

    state.drawing=false; state.pointerId=null;
  }

  function cancelStroke(e){
    if(!state.drawing) return;
    e.preventDefault();
    if(tool.mode==='eraser'){
      finishErase();
    }else{
      // cancel live stroke (do not commit)
      strokeLiveEnd();
      renderAll(); // redraw to erase any partial live path
      state.currentPath=null;
    }
    state.drawing=false; state.pointerId=null;
  }

  // ===== Erasing (stroke-level) =====
  function eraseAt(pt){
    const idx = hitStrokeIndex(pt);
    if(idx!==-1){
      const [removed] = state.paths.splice(idx,1);
      state.eraseBatch.push({ path: removed, index: idx });
      renderAll();
    }
  }
  function finishErase(){
    const batch = state.eraseBatch || [];
    if(batch.length){
      state.undoStack.push({ type:'erase', entries: batch });
      state.redoStack.length=0;
      updateHistoryUI();
    }
    state.eraseBatch=null;
  }

  // ===== History actions =====
  undoBtn.addEventListener('click', () => {
    if(!state.undoStack.length) return;
    const action = state.undoStack.pop();

    if(action.type==='draw'){
      const path = action.path;
      const i = state.paths.lastIndexOf(path);
      if(i!==-1) state.paths.splice(i,1);
      else state.paths.pop();
      state.redoStack.push({ type:'draw', path });
    }

    else if(action.type==='erase'){
      // Put back removed strokes at their original indices
      const entries = action.entries||[];
      for(let i=entries.length-1;i>=0;i--){
        const { path, index } = entries[i];
        state.paths.splice(index, 0, path);
      }
      state.redoStack.push({ type:'erase', entries });
    }

    else if(action.type==='clear'){
      // Restore previous snapshot
      state.paths = deepClonePaths(action.prev);
      state.redoStack.push({ type:'clear', prev: deepClonePaths(action.prev) });
    }

    renderAll(); updateHistoryUI();
  });

  redoBtn.addEventListener('click', () => {
    if(!state.redoStack.length) return;
    const action = state.redoStack.pop();

    if(action.type==='draw'){
      state.paths.push(action.path);
      state.undoStack.push({ type:'draw', path: action.path });
    }

    else if(action.type==='erase'){
      const performed=[];
      (action.entries||[]).forEach(({ path, index })=>{
        const i = state.paths.indexOf(path);
        if(i!==-1){
          const [rm] = state.paths.splice(i,1);
          performed.push({ path: rm, index: i });
        }else if(index>=0 && index<state.paths.length){
          const [rm] = state.paths.splice(index,1);
          performed.push({ path: rm, index });
        }
      });
      if(performed.length) state.undoStack.push({ type:'erase', entries: performed });
    }

    else if(action.type==='clear'){
      // Apply clear again
      const prevNow = deepClonePaths(state.paths);
      state.paths.length = 0;
      state.undoStack.push({ type:'clear', prev: prevNow });
    }

    renderAll(); updateHistoryUI();
  });

  clearBtn.addEventListener('click', () => {
    const snapshot = deepClonePaths(state.paths);
    if(snapshot.length===0){ return; }
    state.paths.length = 0;
    state.undoStack.push({ type:'clear', prev: snapshot });
    state.redoStack.length=0;
    renderAll(); updateHistoryUI();
  });

  function deepClonePaths(arr){
    return arr.map(p => ({
      color:p.color, width:p.width, erase:p.erase,
      points: p.points.map(q => ({ x:q.x, y:q.y }))
    }));
  }

  // ===== UI wiring =====
  colorBtns.forEach(b=>{
    b.addEventListener('click', ()=>{
      tool.color = b.dataset.color; updateColorUI(); updateToolUI(); updateSizeUI();
      tool.mode = 'pen';
    });
  });
  toolBtns.forEach(b=>{
    b.addEventListener('click', ()=>{
      tool.mode = b.dataset.tool; updateToolUI(); updateSizeUI();
    });
  });
  sizeSlider.addEventListener('input', e=>{
    tool.size = clamp(+e.target.value||DEFAULT_SIZE, MIN_SIZE, MAX_SIZE);
    updateSizeUI();
  });
  stylusBtn.addEventListener('click', ()=>{
    tool.stylusOnly = !tool.stylusOnly;
    stylusBtn.setAttribute('aria-pressed', String(tool.stylusOnly));
    stylusBtn.textContent = tool.stylusOnly ? 'Stylus-only' : 'Pen/Touch';
  });

  // ===== Pointer events =====
  pad.addEventListener('pointerdown', startStroke, { passive:false });
  pad.addEventListener('pointermove', moveStroke, { passive:false });
  pad.addEventListener('pointerup',   endStroke,   { passive:false });
  pad.addEventListener('pointercancel', cancelStroke, { passive:false });
  pad.addEventListener('pointerleave',  cancelStroke, { passive:false });

  // Prevent iPad gestures interfering
  ['touchstart','touchmove','gesturestart'].forEach(ev=>{
    pad.addEventListener(ev, e=>{ e.preventDefault(); }, { passive:false });
  });

  // ===== Init =====
  resetCanvas();
  updateColorUI(); updateToolUI(); updateSizeUI(); updateHistoryUI();
  fitCanvasToStage();

  // Refit on viewport changes (orientation, split view, etc.)
  window.addEventListener('resize', fitCanvasToStage);
  window.addEventListener('orientationchange', fitCanvasToStage);
  if(window.visualViewport){
    visualViewport.addEventListener('resize', fitCanvasToStage);
  }
})();
</script>
</body>
</html>
