<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <title>Student - Minimal</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      color-scheme: light;
    }
    html,
    body {
      height: 100%;
      min-height: 100dvh;
      overflow: hidden;
    }
    body {
      position: fixed;
      inset: 0;
      height: 100dvh;
      width: 100%;
    }
    .color-btn {
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .color-btn:hover {
      transform: scale(1.05);
    }
    .color-btn.active {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.95), 0 0 0 6px rgba(15, 118, 110, 0.3);
      border-color: rgba(15, 118, 110, 0.7);
    }
    .tool-btn.active {
      background: rgb(15 118 110);
      color: white;
      border-color: rgb(15 118 110);
      box-shadow: 0 10px 25px rgba(15, 118, 110, 0.25);
    }
    .stylus-indicator.off {
      background: rgb(226 232 240);
      color: rgb(100 116 139);
    }
    .status-dot {
      appearance: none;
      border: none;
      width: 14px;
      height: 14px;
      border-radius: 9999px;
      background: #f59e0b;
      box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.2);
      transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      display: inline-flex;
    }
    .status-dot.status-dot--connected {
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.25);
    }
    .status-dot.status-dot--error {
      background: #ef4444;
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.25);
    }
  </style>
</head>
  <body class="bg-gradient-to-br from-emerald-100 via-white to-slate-100 flex items-center justify-center p-4">
  <div
    id="loginForm"
    class="w-full max-w-md rounded-3xl bg-white/95 p-10 shadow-[0_30px_70px_rgba(14,116,144,0.35)] backdrop-blur-lg max-h-[calc(100dvh-2rem)] overflow-y-auto"
  >
    <h1 class="text-center text-3xl font-bold text-slate-900">Student Login</h1>
    <p class="mt-2 text-center text-slate-500">Join your classroom session to start drawing.</p>
    <div class="mt-8 space-y-5">
      <div>
        <label for="usernameInput" class="text-sm font-semibold text-slate-600">Name</label>
        <input
          type="text"
          id="usernameInput"
          placeholder="Your name"
          maxlength="30"
          required
          autofocus
          class="mt-2 w-full rounded-2xl border-2 border-slate-200 px-4 py-3 text-base font-medium text-slate-800 shadow-sm transition focus:border-emerald-500 focus:outline-none focus:ring-4 focus:ring-emerald-200"
        />
      </div>
      <div>
        <label for="sessionInput" class="text-sm font-semibold text-slate-600">Session code</label>
        <input
          type="text"
          id="sessionInput"
          placeholder="Session code (e.g., ABC123)"
          maxlength="10"
          required
          value="TEST123"
          class="mt-2 w-full rounded-2xl border-2 border-slate-200 px-4 py-3 text-base font-medium uppercase tracking-[0.3em] text-slate-800 shadow-sm transition focus:border-emerald-500 focus:outline-none focus:ring-4 focus:ring-emerald-200"
        />
      </div>
      <button
        id="loginBtn"
        class="w-full rounded-2xl bg-gradient-to-r from-emerald-600 to-emerald-500 px-6 py-3.5 text-lg font-semibold text-white shadow-lg shadow-emerald-900/30 transition hover:scale-[1.01] hover:shadow-emerald-900/40 focus:outline-none focus:ring-4 focus:ring-emerald-200"
      >
        Join Session
      </button>
    </div>
  </div>

  <div
    id="appContainer"
    class="hidden flex h-[calc(100dvh-2.5rem)] w-full max-w-[1120px] flex-col gap-3 rounded-[24px] border border-emerald-100/60 bg-white/85 p-3 text-slate-700 shadow-[0_35px_80px_rgba(15,118,110,0.18)] backdrop-blur"
  >
    <div class="flex items-center justify-between rounded-2xl border border-emerald-100 bg-white/70 px-3 py-2.5">
      <div class="min-w-0">
        <h1 class="text-lg font-semibold tracking-tight text-slate-900">Student Canvas</h1>
        <p id="connectionLabel" class="text-xs font-medium text-slate-500">Preparing session...</p>
      </div>
      <div class="flex items-center gap-2">
        <button
          id="status"
          type="button"
          class="status-dot"
          aria-live="polite"
          aria-label="Connecting..."
          title="Connecting..."
        >
          <span id="statusText" class="sr-only">Connecting...</span>
        </button>
        <button
          id="stylusToggle"
          class="stylus-indicator inline-flex items-center rounded-lg bg-blue-100 px-2.5 py-1 text-[11px] font-semibold text-blue-700 transition hover:bg-blue-200"
        >
          Stylus mode (pen only)
        </button>
        <button
          id="swapToolbarBtn"
          type="button"
          class="inline-flex items-center justify-center rounded-lg border border-emerald-200 bg-white px-2.5 py-1 text-[11px] font-semibold text-emerald-700 shadow-sm transition hover:border-emerald-300 hover:text-emerald-800 focus:outline-none focus:ring-4 focus:ring-emerald-200"
        >
          Move toolbar to right
        </button>
      </div>
    </div>

    <div id="workspace" class="flex flex-1 min-h-0 items-stretch gap-3 overflow-hidden">
      <div
        id="toolbarWrapper"
        class="flex min-h-0 w-[158px] flex-col rounded-3xl border border-slate-200 bg-white/95 p-3 text-slate-700 shadow-[0_22px_55px_rgba(15,23,42,0.16)]"
      >
        <div class="flex-1 space-y-4 overflow-y-auto pr-1">
          <div class="flex flex-col items-center gap-3">
            <span class="text-[11px] font-semibold uppercase tracking-[0.3em] text-slate-400">Colors</span>
            <div id="colorPalette" class="flex flex-col items-center gap-2.5"></div>
          </div>
          <div class="space-y-3">
            <span class="block text-[11px] font-semibold uppercase tracking-[0.3em] text-slate-400">Tools</span>
            <div class="flex flex-col gap-2">
              <button
                class="tool-btn rounded-lg border border-slate-200 bg-white px-2.5 py-1 text-[11px] font-semibold text-slate-600 shadow-sm transition hover:border-slate-300 hover:bg-slate-50"
                data-tool="pen"
              >
                Pen
              </button>
              <button
                class="tool-btn rounded-lg border border-slate-200 bg-white px-2.5 py-1 text-[11px] font-semibold text-slate-600 shadow-sm transition hover:border-slate-300 hover:bg-slate-50"
                data-tool="eraser"
              >
                Eraser
              </button>
            </div>
          </div>
          <div class="space-y-3">
            <span class="block text-[11px] font-semibold uppercase tracking-[0.3em] text-slate-400">Brush Size</span>
            <div class="flex items-center justify-between gap-2 rounded-2xl bg-slate-50 px-2.5 py-2 shadow-inner">
              <input
                type="range"
                id="brushSize"
                min="1"
                max="20"
                value="3"
                class="h-1.5 w-full cursor-pointer appearance-none rounded-lg bg-slate-200 accent-emerald-500"
              />
              <span id="sizeDisplay" class="text-xs font-bold text-slate-800">3</span>
            </div>
          </div>
          <div class="space-y-3">
            <span class="block text-[11px] font-semibold uppercase tracking-[0.3em] text-slate-400">History</span>
            <div class="flex flex-col gap-2">
              <button
                id="undoBtn"
                class="action-btn rounded-lg bg-slate-100 px-2.5 py-1 text-[11px] font-semibold text-slate-600 shadow-sm transition hover:bg-slate-200 disabled:cursor-not-allowed disabled:opacity-40"
                disabled
              >
                Undo
              </button>
              <button
                id="redoBtn"
                class="action-btn rounded-lg bg-slate-100 px-2.5 py-1 text-[11px] font-semibold text-slate-600 shadow-sm transition hover:bg-slate-200 disabled:cursor-not-allowed disabled:opacity-40"
                disabled
              >
                Redo
              </button>
              <button
                id="clearBtn"
                class="action-btn rounded-lg bg-rose-100 px-2.5 py-1 text-[11px] font-semibold text-rose-600 shadow-sm transition hover:bg-rose-200"
              >
                Clear
              </button>
            </div>
          </div>
        </div>
      </div>
      <div class="flex min-h-0 flex-1 items-center justify-center rounded-[24px] border border-emerald-100 bg-white/65 p-3 shadow-inner">
        <div
          id="stage"
          class="flex h-full max-h-[640px] w-full max-w-[840px] flex-1 items-center justify-center overflow-hidden rounded-[20px] border border-slate-200 bg-white p-3 shadow-[0_20px_55px_rgba(15,23,42,0.12)]"
        >
          <canvas
            id="canvas"
            width="800"
            height="600"
            class="block max-h-full max-w-full rounded-2xl bg-white shadow-inner shadow-slate-900/5"
          ></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Safe to expose anon key in client; enforce RLS on backend -->
  <script>
    window.SUPABASE_URL = "https://eytswszeopdxmtxxbkrb.supabase.co";
    window.SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5dHN3c3plb3BkeG10eHhia3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1NTI5ODQsImV4cCI6MjA3NDEyODk4NH0.7skddGtrUoXluvK9JDS54bpmKCxVYeofzWATmJIgABE";
  </script>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.4/+esm';

    /* ----------------- DOM ----------------- */
    const canvas = document.getElementById('canvas');
    const statusEl = document.getElementById('status');
    const statusTextEl = document.getElementById('statusText');
    const connectionLabel = document.getElementById('connectionLabel');
    const loginForm = document.getElementById('loginForm');
    const appContainer = document.getElementById('appContainer');
    const usernameInput = document.getElementById('usernameInput');
    const sessionInput = document.getElementById('sessionInput');
    const loginBtn = document.getElementById('loginBtn');

    const colorPaletteEl = document.getElementById('colorPalette');
    const toolBtns = document.querySelectorAll('.tool-btn');
    const brushSizeInput = document.getElementById('brushSize');
    const sizeDisplay = document.getElementById('sizeDisplay');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const stylusToggle = document.getElementById('stylusToggle');
    const swapToolbarBtn = document.getElementById('swapToolbarBtn');
    const workspace = document.getElementById('workspace');
    const stage = document.getElementById('stage');

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;

    const COLOR_PRESETS = [
      { label: 'Black', value: '#111827' },
      { label: 'Blue', value: '#2563eb' },
      { label: 'Green', value: '#16a34a' }
    ];

    canvas.style.touchAction = 'none';

    /* ----------------- Canvas / DPR ----------------- */
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    let dpr = 1;

    function resizeCanvasForDPR() {
      dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width = Math.round(CANVAS_WIDTH * dpr);
      canvas.height = Math.round(CANVAS_HEIGHT * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      redrawCanvas();
    }

    function fitCanvasToStage() {
      if (!stage) return;
      const style = getComputedStyle(stage);
      const padX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      const padY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
      const availW = Math.max(0, stage.clientWidth - padX);
      const availH = Math.max(0, stage.clientHeight - padY);
      const scale = Math.min(availW / CANVAS_WIDTH, availH / CANVAS_HEIGHT, 1);
      canvas.style.width = `${CANVAS_WIDTH * scale}px`;
      canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
    }

    const stageObserver = new ResizeObserver(fitCanvasToStage);
    if (stage) stageObserver.observe(stage);
    window.addEventListener('orientationchange', () => setTimeout(() => {
      fitCanvasToStage();
      resizeCanvasForDPR();
    }, 150));
    window.addEventListener('resize', fitCanvasToStage);
    fitCanvasToStage();

    /* ----------------- State ----------------- */
    let sbClient = null;
    let channel = null;
    let username = '';
    let sessionCode = '';

    let currentColor = COLOR_PRESETS[0].value;
    let currentTool = 'pen';
    let brushSize = 3;
    let stylusOnly = true;

    // timeline
    let strokes = [];         // [{id,color,size,points:[{x,y}]}] and erase actions {type:'erase',deletedIds:[]}
    let historyStep = -1;

    // draw session
    let activePointerId = null;
    let activeStroke = null;  // {id,color,size,points:[]}
    let liveStrokeActive = false;

    // eraser
    let isErasing = false;
    let lastErasePoint = null;
    let erasedStrokes = [];   // strokes deleted during current drag

    const MIN_SAMPLE_DISTANCE = 0.45;
    const INTERPOLATION_STEP = 3.2;

    /* ----------------- UI wiring ----------------- */
    function setStatus(kind, text) {
      connectionLabel.textContent = text;
      statusEl.className = 'status-dot';
      if (kind === 'error') {
        statusEl.classList.add('status-dot--error');
      } else if (kind === 'connected') {
        statusEl.classList.add('status-dot--connected');
      }
      statusEl.setAttribute('title', text);
      statusEl.setAttribute('aria-label', text);
      if (statusTextEl) statusTextEl.textContent = text;
    }
    setStatus('connecting', 'Waiting to connect');

    function updateColorSelection() {
      const buttons = colorPaletteEl.querySelectorAll('.color-btn');
      buttons.forEach(btn => btn.classList.toggle('active', btn.dataset.color === currentColor));
    }

    function renderColorButtons() {
      colorPaletteEl.innerHTML = '';
      COLOR_PRESETS.forEach(preset => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'color-btn flex h-9 w-9 items-center justify-center rounded-full border-2 border-transparent shadow-sm';
        btn.dataset.color = preset.value;
        btn.title = preset.label;
        btn.setAttribute('aria-label', preset.label);
        btn.style.background = preset.value;
        btn.addEventListener('click', () => {
          currentColor = preset.value;
          updateColorSelection();
          if (currentTool === 'eraser') {
            currentTool = 'pen';
            updateToolButtons();
          }
        });
        colorPaletteEl.appendChild(btn);
      });
      updateColorSelection();
    }
    renderColorButtons();
    function updateToolButtons() {
      toolBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === currentTool));
    }
    toolBtns.forEach(btn => btn.addEventListener('click', () => {
      currentTool = btn.dataset.tool;
      updateToolButtons();
    }));
    updateToolButtons();

    brushSizeInput.addEventListener('input', e => {
      brushSize = parseInt(e.target.value, 10);
      sizeDisplay.textContent = brushSize;
    });

    stylusToggle.addEventListener('click', () => {
      stylusOnly = !stylusOnly;
      stylusToggle.classList.toggle('off', !stylusOnly);
      stylusToggle.textContent = stylusOnly ? 'Stylus mode (pen only)' : 'All inputs';
    });

    let toolbarOnLeft = true;
    function updateToolbarPosition() {
      if (toolbarOnLeft) {
        workspace.classList.remove('flex-row-reverse');
        swapToolbarBtn.textContent = 'Move toolbar to right';
        swapToolbarBtn.setAttribute('aria-pressed', 'false');
      } else {
        workspace.classList.add('flex-row-reverse');
        swapToolbarBtn.textContent = 'Move toolbar to left';
        swapToolbarBtn.setAttribute('aria-pressed', 'true');
      }
      requestAnimationFrame(fitCanvasToStage);
    }
    swapToolbarBtn.addEventListener('click', () => {
      toolbarOnLeft = !toolbarOnLeft;
      updateToolbarPosition();
    });
    updateToolbarPosition();

    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    clearBtn.addEventListener('click', clearCanvas);

    /* ----------------- Session persistence ----------------- */
    function saveToSession() {
      try {
        sessionStorage.setItem('student_drawing_' + username, JSON.stringify({
          strokes, historyStep, username, timestamp: Date.now()
        }));
      } catch {}
    }
    function loadFromSession() {
      try {
        const raw = sessionStorage.getItem('student_drawing_' + username);
        if (!raw) return;
        const data = JSON.parse(raw);
        strokes = data.strokes || [];
        historyStep = Number.isFinite(data.historyStep) ? data.historyStep : -1;
        redrawCanvas();
        updateHistoryButtons();
      } catch {}
    }

    /* ----------------- Timeline helpers ----------------- */
    function addStroke(stroke) {
      if (historyStep < strokes.length - 1) strokes.length = historyStep + 1;
      // clone points lightly
      if (!stroke.type) {
        stroke = { ...stroke, points: stroke.points.map(p => ({ x: p.x, y: p.y })) };
      }
      strokes.push(stroke);
      historyStep = strokes.length - 1;
      redrawCanvas();
      updateHistoryButtons();
      saveToSession();
    }

    function updateHistoryButtons() {
      undoBtn.disabled = historyStep < 0;
      redoBtn.disabled = historyStep >= strokes.length - 1;
    }

    function getVisibleStrokeIds() {
      const deleted = new Set();
      const visible = new Set();
      for (let i = 0; i <= historyStep; i++) {
        const s = strokes[i];
        if (!s) continue;
        if (s.type === 'erase') s.deletedIds.forEach(id => deleted.add(id));
        else visible.add(s.id);
      }
      deleted.forEach(id => visible.delete(id));
      return visible;
    }

    function computeStateDiff(oldSet, newSet) {
      const added = [], removed = [];
      newSet.forEach(id => {
        if (!oldSet.has(id)) {
          const s = strokes.find(x => x.id === id && !x.type);
          if (s) added.push({ id: s.id, color: s.color, size: s.size, points: s.points });
        }
      });
      oldSet.forEach(id => { if (!newSet.has(id)) removed.push(id); });
      return { added, removed };
    }

    function undo() {
      if (historyStep < 0) return;
      const oldV = getVisibleStrokeIds();
      historyStep--;
      const newV = getVisibleStrokeIds();
      redrawCanvas(); updateHistoryButtons(); saveToSession();
      const diff = computeStateDiff(oldV, newV);
      if (channel && (diff.added.length || diff.removed.length)) {
        channel.send({ type:'broadcast', event:'student_state_change', payload:{ username, added: diff.added, removed: diff.removed }});
      }
    }

    function redo() {
      if (historyStep >= strokes.length - 1) return;
      const oldV = getVisibleStrokeIds();
      historyStep++;
      const newV = getVisibleStrokeIds();
      redrawCanvas(); updateHistoryButtons(); saveToSession();
      const diff = computeStateDiff(oldV, newV);
      if (channel && (diff.added.length || diff.removed.length)) {
        channel.send({ type:'broadcast', event:'student_state_change', payload:{ username, added: diff.added, removed: diff.removed }});
      }
    }

    function clearCanvas() {
      if (historyStep < strokes.length - 1) strokes.length = historyStep + 1;
      const visible = getVisibleStrokeIds();
      if (!visible.size) { redrawCanvas(); return; }
      const deletedIds = Array.from(visible);
      strokes.push({ type: 'erase', deletedIds });
      historyStep = strokes.length - 1;
      redrawCanvas(); updateHistoryButtons(); saveToSession();
      const diff = computeStateDiff(visible, getVisibleStrokeIds());
      if (channel && (diff.added.length || diff.removed.length)) {
        channel.send({ type:'broadcast', event:'student_state_change', payload:{ username, added: diff.added, removed: diff.removed }});
      }
      channel?.send({ type:'broadcast', event:'student_clear', payload:{ username }});
    }

    /* ----------------- Drawing ----------------- */
    function drawDotPath(targetCtx, point, size, color) {
      if (!point) return;
      targetCtx.beginPath();
      const radius = Math.max(0.25, size / 2);
      targetCtx.arc(point.x, point.y, radius, 0, Math.PI * 2);
      targetCtx.fillStyle = color;
      targetCtx.fill();
    }

    function drawSmoothStrokePath(targetCtx, points, color, size) {
      if (!points?.length) return;

      const strokeColor = color || '#111827';
      const strokeSize = Math.max(0.5, Number.isFinite(size) ? size : 3);

      targetCtx.save();
      targetCtx.lineCap = 'round';
      targetCtx.lineJoin = 'round';
      targetCtx.strokeStyle = strokeColor;
      targetCtx.lineWidth = strokeSize;
      targetCtx.fillStyle = strokeColor;

      if (points.length === 1) {
        drawDotPath(targetCtx, points[0], strokeSize, strokeColor);
        targetCtx.restore();
        return;
      }

      if (points.length === 2) {
        targetCtx.beginPath();
        targetCtx.moveTo(points[0].x, points[0].y);
        targetCtx.lineTo(points[1].x, points[1].y);
        targetCtx.stroke();
        drawDotPath(targetCtx, points[1], strokeSize, strokeColor);
        targetCtx.restore();
        return;
      }

      targetCtx.beginPath();
      targetCtx.moveTo(points[0].x, points[0].y);

      for (let i = 0; i < points.length - 1; i++) {
        const p0 = i === 0 ? points[0] : points[i - 1];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = i + 2 < points.length ? points[i + 2] : points[i + 1];

        const cp1x = p1.x + (p2.x - p0.x) / 6;
        const cp1y = p1.y + (p2.y - p0.y) / 6;
        const cp2x = p2.x - (p3.x - p1.x) / 6;
        const cp2y = p2.y - (p3.y - p1.y) / 6;

        targetCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }

      targetCtx.stroke();
      drawDotPath(targetCtx, points[points.length - 1], strokeSize, strokeColor);
      targetCtx.restore();
    }

    function appendPointWithInterpolation(array, point) {
      if (!point) return;
      const last = array[array.length - 1];
      if (last) {
        const dx = point.x - last.x;
        const dy = point.y - last.y;
        const dist = Math.hypot(dx, dy);
        if (dist < MIN_SAMPLE_DISTANCE) {
          last.x += dx * 0.5;
          last.y += dy * 0.5;
          return;
        }
        const steps = Math.min(6, Math.floor(dist / INTERPOLATION_STEP));
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          array.push({
            x: last.x + dx * t,
            y: last.y + dy * t
          });
        }
      }
      array.push(point);
    }

    function appendSamples(array, samples) {
      const added = [];
      samples.forEach(sample => {
        const before = array.length;
        appendPointWithInterpolation(array, { x: sample.x, y: sample.y });
        if (array.length > before) {
          for (let i = before; i < array.length; i++) added.push(array[i]);
        }
      });
      return added;
    }

    function getCoalescedSamples(e) {
      const list = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
      return list.map(item => getCanvasPoint(item));
    }

    function redrawCanvas() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      const deleted = new Set();
      for (let i = 0; i <= historyStep; i++) {
        const a = strokes[i];
        if (a?.type === 'erase') a.deletedIds.forEach(id => deleted.add(id));
      }
      if (isErasing && erasedStrokes.length) erasedStrokes.forEach(s => deleted.add(s.id));

      for (let i = 0; i <= historyStep; i++) {
        const s = strokes[i];
        if (!s || s.type === 'erase') continue;
        if (deleted.has(s.id)) continue;
        drawStroke(s);
      }
    }

    function drawStroke(stroke) {
      if (!stroke.points?.length) return;
      ctx.globalCompositeOperation = 'source-over';
      drawSmoothStrokePath(ctx, stroke.points, stroke.color, stroke.size);
    }

    function getCanvasPoint(ev) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = CANVAS_WIDTH / rect.width || 1;
      const scaleY = CANVAS_HEIGHT / rect.height || 1;
      return {
        x: (ev.clientX - rect.left) * scaleX,
        y: (ev.clientY - rect.top) * scaleY
      };
    }

    function distToSegmentSquared(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      const len2 = dx*dx + dy*dy;
      if (len2 === 0) return (px - x1)**2 + (py - y1)**2;
      let t = ((px-x1)*dx + (py-y1)*dy) / len2;
      t = Math.max(0, Math.min(1, t));
      const qx = x1 + t*dx, qy = y1 + t*dy;
      return (px - qx)**2 + (py - qy)**2;
    }

    function deleteStrokesInPath(x, y) {
      const eraserRadius = Math.max(30, brushSize * 3);
      const deletedNow = new Set();

      const alreadyDeleted = new Set();
      for (let i = 0; i <= historyStep; i++) {
        const a = strokes[i];
        if (a?.type === 'erase') a.deletedIds.forEach(id => alreadyDeleted.add(id));
      }

      for (let i = historyStep; i >= 0; i--) {
        const s = strokes[i];
        if (!s || s.type === 'erase') continue;
        if (alreadyDeleted.has(s.id)) continue;
        if (erasedStrokes.find(e => e.id === s.id)) continue;

        let hit = false;
        for (let j = 0; j < s.points.length; j++) {
          const p = s.points[j];
          const dist = Math.hypot(p.x - x, p.y - y);
          if (dist < eraserRadius + (s.size || 3) / 2) { hit = true; break; }
          if (j > 0) {
            const q = s.points[j - 1];
            const d2 = distToSegmentSquared(x, y, q.x, q.y, p.x, p.y);
            if (d2 < (eraserRadius + (s.size || 3) / 2) ** 2) { hit = true; break; }
          }
        }
        if (hit) {
          deletedNow.add(s.id);
          erasedStrokes.push(s);
          channel?.send({ type:'broadcast', event:'student_stroke_delete', payload:{ username, strokeId: s.id }});
        }
      }
      if (deletedNow.size) redrawCanvas();
    }

    canvas.addEventListener('pointerdown', (e) => {
      if (stylusOnly && e.pointerType !== 'pen') return;

      e.preventDefault();
      activePointerId = e.pointerId;
      try { canvas.setPointerCapture(activePointerId); } catch {}

      const p = getCanvasPoint(e);

      if (currentTool === 'eraser') {
        isErasing = true;
        erasedStrokes = [];
        lastErasePoint = p;
        deleteStrokesInPath(p.x, p.y);
        return;
      }

      activeStroke = {
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        color: currentColor,
        size: brushSize,
        points: [p]
      };

      liveStrokeActive = true;
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = activeStroke.color;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = activeStroke.size;
      drawDotPath(ctx, p, activeStroke.size, activeStroke.color);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);

      channel?.send({ type:'broadcast', event:'student_stroke_start', payload:{ username, stroke:{ id: activeStroke.id, color: activeStroke.color, size: activeStroke.size } }});
    });

    function handlePointerMove(e) {
      if (activePointerId !== e.pointerId) return;

      if (isErasing) {
        e.preventDefault();
        const list = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
        for (const ce of list) {
          const p = getCanvasPoint(ce);
          if (lastErasePoint) {
            const dist = Math.hypot(p.x - lastErasePoint.x, p.y - lastErasePoint.y);
            const steps = Math.max(1, Math.floor(dist / 8));
            for (let i = 1; i <= steps; i++) {
              const t = i / steps;
              deleteStrokesInPath(
                lastErasePoint.x + (p.x - lastErasePoint.x) * t,
                lastErasePoint.y + (p.y - lastErasePoint.y) * t
              );
            }
          } else {
            deleteStrokesInPath(p.x, p.y);
          }
          lastErasePoint = p;
        }
        return;
      }

      if (!activeStroke) return;

      e.preventDefault();
      const samples = getCoalescedSamples(e);
      if (!samples.length) return;

      const added = appendSamples(activeStroke.points, samples);
      if (!added.length) return;

      added.forEach(pt => {
        ctx.lineTo(pt.x, pt.y);
      });
      ctx.stroke();

      const last = activeStroke.points[activeStroke.points.length - 1];
      if (last) {
        channel?.send({ type:'broadcast', event:'student_stroke_point', payload:{ username, strokeId: activeStroke.id, x: last.x, y: last.y }});
      }
    }

    canvas.addEventListener('pointermove', handlePointerMove, { passive: false });

    function finalizePointer(e) {
      if (activePointerId !== e.pointerId) return;

      if (isErasing) {
        isErasing = false;
        lastErasePoint = null;
        if (erasedStrokes.length) {
          const eraseAction = {
            id: `${Date.now()}-erase-${Math.random().toString(16).slice(2)}`,
            type: 'erase',
            deletedStrokes: erasedStrokes.map(s => ({ ...s, points: s.points.map(p => ({x:p.x, y:p.y})) })),
            deletedIds: erasedStrokes.map(s => s.id)
          };
          addStroke(eraseAction);
        }
        try { canvas.releasePointerCapture(activePointerId); } catch {}
        activePointerId = null;
        return;
      }

      if (!activeStroke) {
        try { canvas.releasePointerCapture(activePointerId); } catch {}
        activePointerId = null;
        if (liveStrokeActive) {
          ctx.restore();
          liveStrokeActive = false;
          redrawCanvas();
        }
        return;
      }

      const finalized = {
        id: activeStroke.id,
        color: activeStroke.color,
        size: activeStroke.size,
        points: activeStroke.points.map(p => ({ x:p.x, y:p.y }))
      };

      if (liveStrokeActive) {
        ctx.restore();
        liveStrokeActive = false;
      }

      activeStroke = null;
      try { canvas.releasePointerCapture(activePointerId); } catch {}
      activePointerId = null;

      addStroke(finalized);
      channel?.send({ type:'broadcast', event:'student_stroke_end', payload:{ username, stroke: finalized }});
    }

    canvas.addEventListener('pointerup', finalizePointer);
    canvas.addEventListener('pointercancel', finalizePointer);
    canvas.addEventListener('pointerleave', (e) => {
      if (activePointerId === e.pointerId) finalizePointer(e);
    });

    /* ----------------- Supabase wiring ----------------- */
    function wireTeacherEvents(ch) {
      ch.on('broadcast', { event: 'teacher_stroke_end' }, ({ payload }) => {
        if (payload.target !== username) return;
        const s = payload.stroke;
        if (!s?.id) return;
        addStroke({ id: s.id, color: s.color || '#111827', size: s.size || 3, points: s.points || [], isTeacher: true });
      });

      ch.on('broadcast', { event: 'teacher_state_change' }, ({ payload }) => {
        if (payload.target !== username) return;
        (payload.added || []).forEach(a => {
          if (!strokes.find(s => s.id === a.id)) {
            strokes.push({ id: a.id, color: a.color || '#111827', size: a.size || 3, points: a.points || [], isTeacher: true });
            historyStep = strokes.length - 1;
          }
        });
        (payload.removed || []).forEach(id => {
          const idx = strokes.findIndex(s => s.id === id);
          if (idx >= 0) {
            strokes.splice(idx, 1);
            historyStep = Math.min(historyStep, strokes.length - 1);
          }
        });
        redrawCanvas(); updateHistoryButtons(); saveToSession();
      });

      ch.on('broadcast', { event: 'teacher_stroke_delete' }, ({ payload }) => {
        if (payload.target !== username) return;
        const idx = strokes.findIndex(s => s.id === payload.strokeId);
        if (idx >= 0) {
          strokes.splice(idx, 1);
          historyStep = Math.min(historyStep, strokes.length - 1);
          redrawCanvas(); updateHistoryButtons(); saveToSession();
        }
      });

      ch.on('broadcast', { event: 'teacher_clear' }, ({ payload }) => {
        if (payload.target !== username) return;
        strokes = strokes.filter(s => s.type === 'erase' || !s.isTeacher); // remove teacher-only items; keep erase actions if any
        historyStep = strokes.length - 1;
        redrawCanvas(); updateHistoryButtons(); saveToSession();
      });
    }

    async function setupSupabase() {
      setStatus('connecting', 'Connecting to Supabase...');
      const { SUPABASE_URL, SUPABASE_ANON_KEY } = window;
      if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
        setStatus('error', 'ERROR: Supabase keys missing.');
        return;
      }
      sbClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      channel = sbClient.channel(`minimal-${sessionCode}`, { config: { broadcast: { ack: false } } });
      wireTeacherEvents(channel);
      channel.subscribe(async (st) => {
        if (st === 'SUBSCRIBED') {
          setStatus('connected', `Connected as ${username}`);
          await channel.send({ type:'broadcast', event:'student_ready', payload:{ username, sessionCode }});
        } else if (st === 'CHANNEL_ERROR') {
          setStatus('error', 'Connection error');
        }
      });
    }

    /* ----------------- Login ----------------- */
    async function login() {
      username = usernameInput.value.trim();
      sessionCode = sessionInput.value.trim().toUpperCase();
      if (!username || !sessionCode) {
        alert('Please enter both name and session code');
        return;
      }
      loginForm.classList.add('hidden');
      appContainer.classList.remove('hidden');
      requestAnimationFrame(() => {
        fitCanvasToStage();
        resizeCanvasForDPR();
      });
      loadFromSession();
      await setupSupabase();
    }
    loginBtn.addEventListener('click', login);
    usernameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') login(); });
    sessionInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') login(); });

    // initial paint
    fitCanvasToStage();
    resizeCanvasForDPR();
  </script>
</body>
</html>
