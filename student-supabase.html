<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Student ‚Ä¢ Live Drawing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              display: ['"Plus Jakarta Sans"', "ui-sans-serif", "system-ui"],
            },
            colors: {
              leaf: {
                500: "#22c55e",
                600: "#16a34a",
                700: "#15803d",
              },
            },
          },
        },
      };
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Plus Jakarta Sans", ui-sans-serif, system-ui;
      }
      .color-btn {
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 9999px;
        border: 3px solid transparent;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
      }
      .color-btn:hover {
        transform: scale(1.08);
      }
      .color-btn.active {
        box-shadow:
          0 0 0 3px rgba(255, 255, 255, 0.85),
          0 0 0 6px rgba(15, 118, 110, 0.85);
      }
      .tool-btn,
      .action-btn {
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
      }
      .tool-btn:hover,
      .action-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
      }
      .tool-btn.active {
        background: linear-gradient(135deg, #16a34a, #0f766e);
        color: #fff;
        border-color: transparent;
        box-shadow: 0 10px 25px rgba(22, 163, 74, 0.35);
      }
      .action-btn:disabled,
      .tool-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .feedback-toast {
        opacity: 0;
        transform: translate(-50%, 20px);
        transition:
          opacity 0.25s ease,
          transform 0.25s ease;
        pointer-events: none;
      }
      .feedback-toast.show {
        opacity: 1;
        transform: translate(-50%, 0);
      }
      canvas {
        touch-action: none;
      }
    </style>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="absolute inset-0 -z-10 overflow-hidden">
      <div
        class="absolute -top-48 -right-32 h-[32rem] w-[32rem] rounded-full bg-gradient-to-br from-leaf-100 to-emerald-100 blur-3xl"
      ></div>
      <div
        class="absolute -bottom-52 -left-24 h-[36rem] w-[36rem] rounded-full bg-gradient-to-br from-emerald-100 to-teal-100 blur-3xl"
      ></div>
      <div
        class="absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(34,197,94,0.08),_transparent_60%)]"
      ></div>
    </div>

    <main
      class="relative mx-auto flex min-h-screen w-full max-w-5xl flex-col items-center justify-center px-6 py-12"
    >
      <section
        id="loginForm"
        class="w-full max-w-xl space-y-6 rounded-3xl border border-slate-200 bg-white p-8 shadow-2xl shadow-emerald-200"
      >
        <div class="flex items-center gap-3">
          <span
            class="inline-flex h-12 w-12 items-center justify-center rounded-2xl bg-emerald-100 text-2xl"
            >üñäÔ∏è</span
          >
          <div>
            <h1 class="text-3xl font-semibold text-slate-900">
              Join your class canvas
            </h1>
            <p class="text-sm text-slate-600">
              Enter your name and the code shared by your teacher.
            </p>
          </div>
        </div>
        <div class="space-y-4">
          <div class="space-y-2">
            <label
              for="usernameInput"
              class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500"
              >Your name</label
            >
            <input
              type="text"
              id="usernameInput"
              maxlength="30"
              required
              class="w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-base font-semibold text-slate-900 shadow focus:border-leaf-500 focus:outline-none focus:ring-4 focus:ring-leaf-500/30"
              placeholder="Alex Rivera"
            />
          </div>
          <div class="space-y-2">
            <label
              for="sessionInput"
              class="text-xs font-semibold uppercase tracking-[0.2em] text-slate-500"
              >Session code</label
            >
            <input
              type="text"
              id="sessionInput"
              maxlength="10"
              value="TEST123"
              required
              class="w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-base font-semibold uppercase tracking-[0.3em] text-slate-900 shadow focus:border-leaf-500 focus:outline-none focus:ring-4 focus:ring-leaf-500/30"
              placeholder="ABC123"
            />
          </div>
        </div>
        <button
          id="loginBtn"
          class="inline-flex w-full items-center justify-center gap-2 rounded-xl bg-gradient-to-br from-leaf-600 to-emerald-500 px-6 py-3 text-base font-semibold text-white shadow-lg shadow-emerald-400/40 transition hover:translate-y-[-1px] hover:shadow-xl focus:outline-none focus-visible:ring-4 focus-visible:ring-emerald-400/40"
        >
          Join session
        </button>
      </section>

      <section id="appContainer" class="hidden w-full max-w-5xl space-y-6">
        <header
          class="flex flex-col items-center gap-4 rounded-3xl border border-slate-200 bg-white p-6 text-center shadow-xl shadow-emerald-200"
        >
          <h1 class="text-3xl font-semibold text-slate-900">Your live canvas</h1>
          <p class="text-sm text-slate-600">
            Use undo
            <kbd
              class="rounded bg-slate-200 px-2 py-1 text-[0.7rem] font-semibold uppercase text-slate-800"
              >‚åò</kbd
            >
            +
            <kbd
              class="rounded bg-slate-200 px-2 py-1 text-[0.7rem] font-semibold uppercase text-slate-800"
              >Z</kbd
            >, redo with ‚áß, and switch between pen or eraser anytime.
          </p>
          <span
            id="status"
            class="inline-flex items-center gap-2 rounded-full px-4 py-1.5 text-sm font-semibold tracking-tight text-slate-600 ring-1 ring-slate-200"
            aria-live="polite"
            >Connecting‚Ä¶</span
          >
        </header>

        <div
          class="rounded-[2.5rem] border border-slate-200 bg-white p-1 shadow-2xl shadow-emerald-200"
        >
          <div
            class="flex flex-col gap-6 rounded-[2.3rem] border border-slate-200 bg-white p-6"
          >
            <div
              class="toolbar flex flex-wrap items-center justify-center gap-3 rounded-full border border-slate-200 bg-slate-50 px-6 py-3 shadow-lg shadow-slate-200"
            >
              <div
                class="flex items-center gap-2"
                role="group"
                aria-label="Brush color"
              >
                <button
                  class="color-btn"
                  style="background: #000000"
                  data-color="#000000"
                  title="Black"
                ></button>
                <button
                  class="color-btn"
                  style="background: #3b82f6"
                  data-color="#3b82f6"
                  title="Blue"
                ></button>
                <button
                  class="color-btn"
                  style="background: #22c55e"
                  data-color="#22c55e"
                  title="Green"
                ></button>
              </div>
              <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
              <div
                class="flex items-center gap-2"
                role="group"
                aria-label="Tool"
              >
                <button
                  class="tool-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600"
                  data-tool="pen"
                >
                  Pen
                </button>
                <button
                  class="tool-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600"
                  data-tool="eraser"
                >
                  Eraser
                </button>
              </div>
              <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
              <div class="flex items-center gap-3" aria-label="Brush size">
                <span
                  class="text-xs font-semibold uppercase tracking-wide text-slate-500"
                  >Size</span
                >
                <input
                  type="range"
                  id="brushSize"
                  min="1"
                  max="20"
                  value="3"
                  class="h-1.5 w-28 cursor-pointer appearance-none rounded-full bg-slate-200"
                />
                <span
                  id="sizeDisplay"
                  class="text-sm font-semibold text-slate-700"
                  >3</span
                >
              </div>
              <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
              <div class="flex items-center gap-2" aria-label="Canvas actions">
                <button
                  class="action-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600 disabled:opacity-40"
                  id="undoBtn"
                  title="Undo (‚åò/Ctrl + Z)"
                  disabled
                >
                  Undo
                </button>
                <button
                  class="action-btn rounded-full border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-600 disabled:opacity-40"
                  id="redoBtn"
                  title="Redo (‚áß + ‚åò/Ctrl + Z)"
                  disabled
                >
                  Redo
                </button>
                <button
                  class="action-btn rounded-full border border-rose-200 bg-rose-500/10 px-4 py-2 text-sm font-semibold text-rose-600"
                  id="clearBtn"
                  title="Clear your drawing"
                >
                  Clear
                </button>
              </div>
              <span class="hidden h-8 w-px bg-slate-200 lg:block"></span>
              <button
                class="stylus-indicator rounded-full border border-slate-200 bg-emerald-100 px-4 py-2 text-xs font-semibold uppercase tracking-wide text-emerald-800"
                id="stylusToggle"
              >
                Stylus mode (pen only)
              </button>
            </div>

            <div
              class="overflow-hidden rounded-3xl border border-slate-200 bg-white shadow-inner shadow-slate-200"
            >
              <canvas
                id="canvas"
                width="800"
                height="600"
                class="block h-auto w-full max-w-full bg-white"
              ></canvas>
            </div>
          </div>
        </div>
      </section>
    </main>

    <div
      id="feedbackToast"
      class="feedback-toast fixed bottom-6 left-1/2 z-50 -translate-x-1/2 rounded-full bg-white px-5 py-2 text-sm font-semibold text-slate-900 shadow-xl shadow-slate-300/50"
    >
      Action completed
    </div>

    <script>
      window.SUPABASE_URL = "https://eytswszeopdxmtxxbkrb.supabase.co";
      window.SUPABASE_ANON_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5dHN3c3plb3BkeG10eHhpY3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1NTI5ODQsImV4cCI6MjA3NDEyODk4NH0.7skddGtrUoXluvK9JDS54bpmKCxVYeofzWATmJIgABE";
    </script>
    <script type="module">
      import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.4/+esm";

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");
      const loginForm = document.getElementById("loginForm");
      const appContainer = document.getElementById("appContainer");
      const usernameInput = document.getElementById("usernameInput");
      const sessionInput = document.getElementById("sessionInput");
      const loginBtn = document.getElementById("loginBtn");
      const feedbackToast = document.getElementById("feedbackToast");

      const statusStyles = {
        connecting:
          "inline-flex items-center gap-2 rounded-full px-4 py-1.5 text-sm font-semibold tracking-tight text-amber-700 ring-1 ring-amber-200 bg-amber-50",
        connected:
          "inline-flex items-center gap-2 rounded-full px-4 py-1.5 text-sm font-semibold tracking-tight text-emerald-700 ring-1 ring-emerald-200 bg-emerald-50",
        error:
          "inline-flex items-center gap-2 rounded-full px-4 py-1.5 text-sm font-semibold tracking-tight text-rose-700 ring-1 ring-rose-200 bg-rose-50",
        idle:
          "inline-flex items-center gap-2 rounded-full px-4 py-1.5 text-sm font-semibold tracking-tight text-slate-600 ring-1 ring-slate-200 bg-slate-100",
      };

      let supabase, channel;
      let username, sessionCode;
      let isDrawing = false;
      let stylusOnly = true;
      let currentColor = "#000000";
      let currentTool = "pen";
      let brushSize = 3;
      let strokes = [];
      let currentStroke = null;
      let historyStep = -1;
      let lastPoint = null;
      let erasedStrokes = [];
      let isErasing = false;

      const colorBtns = document.querySelectorAll(".color-btn");
      const toolBtns = document.querySelectorAll(".tool-btn");
      const brushSizeInput = document.getElementById("brushSize");
      const sizeDisplay = document.getElementById("sizeDisplay");
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      const clearBtn = document.getElementById("clearBtn");
      const stylusToggle = document.getElementById("stylusToggle");

      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, 800, 600);
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      function updateStatus(state, label) {
        status.textContent = label;
        status.className = statusStyles[state] || statusStyles.idle;
      }

      updateStatus("idle", "Waiting to connect");

      function showFeedback(message) {
        if (!feedbackToast) return;
        feedbackToast.textContent = message;
        feedbackToast.classList.add("show");
        clearTimeout(showFeedback._timeout);
        showFeedback._timeout = setTimeout(() => {
          feedbackToast.classList.remove("show");
        }, 1600);
      }

      function saveToSession() {
        try {
          const sessionData = {
            strokes,
            historyStep,
            username,
            timestamp: Date.now(),
          };
          sessionStorage.setItem(
            "student_drawing_" + username,
            JSON.stringify(sessionData),
          );
        } catch (err) {
          console.warn("Failed to persist drawing session", err);
        }
      }

      function loadFromSession() {
        try {
          const savedData = sessionStorage.getItem(
            "student_drawing_" + username,
          );
          if (savedData) {
            const data = JSON.parse(savedData);
            strokes = data.strokes || [];
            historyStep = data.historyStep ?? -1;
            redrawCanvas();
            updateHistoryButtons();
          }
        } catch (err) {
          console.warn("Unable to restore drawing session", err);
        }
      }

      function addStroke(stroke) {
        if (historyStep < strokes.length - 1) {
          strokes.length = historyStep + 1;
        }
        strokes.push(stroke);
        historyStep = strokes.length - 1;
        redrawCanvas();
        updateHistoryButtons();
        saveToSession();
      }

      function updateHistoryButtons() {
        undoBtn.disabled = historyStep < 0;
        redoBtn.disabled = historyStep >= strokes.length - 1;
      }

      function getVisibleStrokeIds() {
        const deletedIds = new Set();
        const visibleIds = new Set();
        for (let i = 0; i <= historyStep; i++) {
          const item = strokes[i];
          if (!item) continue;
          if (item.type === "erase") {
            item.deletedIds.forEach((id) => deletedIds.add(id));
          } else if (!item.type && !item.isTeacher) {
            visibleIds.add(item.id);
          }
        }
        deletedIds.forEach((id) => visibleIds.delete(id));
        return visibleIds;
      }

      function computeStateDiff(oldVisibleIds, newVisibleIds) {
        const added = [];
        const removed = [];
        newVisibleIds.forEach((id) => {
          if (!oldVisibleIds.has(id)) {
            const stroke = strokes.find((s) => s.id === id);
            if (stroke && !stroke.isTeacher) {
              added.push({
                id: stroke.id,
                color: stroke.color,
                size: stroke.size,
                points: stroke.points,
              });
            }
          }
        });
        oldVisibleIds.forEach((id) => {
          if (!newVisibleIds.has(id)) {
            removed.push(id);
          }
        });
        return { added, removed };
      }

      function undo() {
        if (historyStep >= 0) {
          const oldVisible = getVisibleStrokeIds();
          historyStep--;
          const newVisible = getVisibleStrokeIds();
          redrawCanvas();
          updateHistoryButtons();
          saveToSession();
          const diff = computeStateDiff(oldVisible, newVisible);
          if ((diff.added.length || diff.removed.length) && channel) {
            channel.send({
              type: "broadcast",
              event: "student_state_change",
              payload: { username, added: diff.added, removed: diff.removed },
            });
          }
          showFeedback("Undo");
        }
      }

      function redo() {
        if (historyStep < strokes.length - 1) {
          const oldVisible = getVisibleStrokeIds();
          historyStep++;
          const newVisible = getVisibleStrokeIds();
          redrawCanvas();
          updateHistoryButtons();
          saveToSession();
          const diff = computeStateDiff(oldVisible, newVisible);
          if ((diff.added.length || diff.removed.length) && channel) {
            channel.send({
              type: "broadcast",
              event: "student_state_change",
              payload: { username, added: diff.added, removed: diff.removed },
            });
          }
          showFeedback("Redo");
        }
      }

      function redrawCanvas() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, 800, 600);
        const deletedIds = new Set();
        for (let i = 0; i <= historyStep; i++) {
          const action = strokes[i];
          if (action?.type === "erase") {
            action.deletedIds.forEach((id) => deletedIds.add(id));
          }
        }
        if (isErasing && erasedStrokes.length > 0) {
          erasedStrokes.forEach((stroke) => deletedIds.add(stroke.id));
        }
        for (let i = 0; i <= historyStep; i++) {
          const stroke = strokes[i];
          if (!stroke || stroke.type === "erase") continue;
          if (deletedIds.has(stroke.id)) continue;
          drawStroke(stroke);
        }
      }

      function drawStroke(stroke) {
        if (!stroke?.points?.length) return;
        ctx.globalCompositeOperation = "source-over";
        if (stroke.points.length === 1) {
          const point = stroke.points[0];
          ctx.beginPath();
          ctx.arc(point.x, point.y, stroke.size / 2, 0, Math.PI * 2);
          ctx.fillStyle = stroke.color;
          ctx.fill();
          return;
        }
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.size;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
          const prev = stroke.points[i - 1];
          const curr = stroke.points[i];
          const midX = (prev.x + curr.x) / 2;
          const midY = (prev.y + curr.y) / 2;
          ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
        }
        ctx.stroke();
      }

      function clearCanvas() {
        if (historyStep < strokes.length - 1) {
          strokes.length = historyStep + 1;
        }

        const visibleBeforeClear = getVisibleStrokeIds();
        if (visibleBeforeClear.size === 0) {
          showFeedback("Canvas is already clear");
          return;
        }

        const deletedIds = Array.from(visibleBeforeClear);
        strokes.push({ type: "erase", deletedIds });
        historyStep = strokes.length - 1;

        redrawCanvas();
        updateHistoryButtons();
        saveToSession();

        const newVisible = getVisibleStrokeIds();
        const diff = computeStateDiff(visibleBeforeClear, newVisible);
        if ((diff.added.length || diff.removed.length) && channel) {
          channel.send({
            type: "broadcast",
            event: "student_state_change",
            payload: { username, added: diff.added, removed: diff.removed },
          });
        }

        channel?.send({
          type: "broadcast",
          event: "student_clear",
          payload: { username },
        });

        showFeedback("Canvas cleared");
      }

      undoBtn.addEventListener("click", undo);
      redoBtn.addEventListener("click", redo);
      clearBtn.addEventListener("click", clearCanvas);

      colorBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          colorBtns.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentColor = btn.dataset.color;
          if (currentTool === "eraser") {
            currentTool = "pen";
            updateToolButtons();
          }
        });
      });
      colorBtns[0]?.classList.add("active");

      toolBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          currentTool = btn.dataset.tool;
          updateToolButtons();
        });
      });

      function updateToolButtons() {
        toolBtns.forEach((btn) =>
          btn.classList.toggle("active", btn.dataset.tool === currentTool),
        );
      }
      updateToolButtons();

      brushSizeInput.addEventListener("input", (e) => {
        brushSize = parseInt(e.target.value, 10);
        sizeDisplay.textContent = brushSize;
      });

      stylusToggle.addEventListener("click", () => {
        stylusOnly = !stylusOnly;
        stylusToggle.classList.toggle("bg-emerald-100/80", stylusOnly);
        stylusToggle.classList.toggle("bg-slate-200/60", !stylusOnly);
        stylusToggle.textContent = stylusOnly
          ? "Stylus mode (pen only)"
          : "All inputs enabled";
      });

      function handleHotkeys(event) {
        if (loginForm.classList.contains("hidden")) {
          const isMeta = event.metaKey || event.ctrlKey;
          if (isMeta && event.key.toLowerCase() === "z") {
            event.preventDefault();
            if (event.shiftKey) {
              redo();
            } else {
              undo();
            }
          } else if (isMeta && event.key.toLowerCase() === "y") {
            event.preventDefault();
            redo();
          } else if (event.key === "Backspace" && event.shiftKey) {
            event.preventDefault();
            clearCanvas();
          }
        }
      }
      window.addEventListener("keydown", handleHotkeys);

      canvas.addEventListener("pointerdown", (e) => {
        if (!loginForm.classList.contains("hidden")) return;
        if (stylusOnly && e.pointerType !== "pen") {
          showFeedback("Stylus mode is active");
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (800 / rect.width);
        const y = (e.clientY - rect.top) * (600 / rect.height);

        if (currentTool === "eraser") {
          isErasing = true;
          erasedStrokes = [];
          lastPoint = { x, y };
          deleteStrokesInPath(x, y);
        } else {
          isDrawing = true;
          lastPoint = { x, y };
          currentStroke = {
            id: Date.now() + "-" + Math.random(),
            color: currentColor,
            size: brushSize,
            points: [{ x, y }],
            isTeacher: false,
          };

          ctx.strokeStyle = currentColor;
          ctx.lineWidth = brushSize;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          ctx.moveTo(x, y);

          channel?.send({
            type: "broadcast",
            event: "student_stroke_start",
            payload: {
              username,
              stroke: {
                id: currentStroke.id,
                color: currentColor,
                size: brushSize,
              },
            },
          });
        }
      });

      canvas.addEventListener("pointermove", (e) => {
        if (!loginForm.classList.contains("hidden")) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (800 / rect.width);
        const y = (e.clientY - rect.top) * (600 / rect.height);

        if (isErasing) {
          deleteStrokesInPath(x, y);
          lastPoint = { x, y };
          return;
        }

        if (!isDrawing || !currentStroke) return;

        currentStroke.points.push({ x, y });
        if (lastPoint) {
          const midX = (lastPoint.x + x) / 2;
          const midY = (lastPoint.y + y) / 2;
          ctx.quadraticCurveTo(lastPoint.x, lastPoint.y, midX, midY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(midX, midY);
        }
        lastPoint = { x, y };

        channel?.send({
          type: "broadcast",
          event: "student_stroke_point",
          payload: { username, strokeId: currentStroke.id, x, y },
        });
      });

      canvas.addEventListener("pointerup", () => {
        if (!loginForm.classList.contains("hidden")) return;
        if (isErasing) {
          isErasing = false;
          lastPoint = null;
          if (erasedStrokes.length > 0) {
            const eraseAction = {
              id: Date.now() + "-erase-" + Math.random(),
              type: "erase",
              deletedStrokes: [...erasedStrokes],
              deletedIds: erasedStrokes.map((s) => s.id),
            };
            addStroke(eraseAction);
            const removedIds = eraseAction.deletedIds;
            if (removedIds.length && channel) {
              channel.send({
                type: "broadcast",
                event: "student_state_change",
                payload: { username, added: [], removed: removedIds },
              });
            }
            showFeedback(
              `Erased ${removedIds.length} stroke${removedIds.length > 1 ? "s" : ""}`,
            );
          }
          return;
        }

        if (!isDrawing || !currentStroke) return;

        if (currentStroke.points.length === 1) {
          const point = currentStroke.points[0];
          ctx.beginPath();
          ctx.arc(point.x, point.y, brushSize / 2, 0, Math.PI * 2);
          ctx.fillStyle = currentColor;
          ctx.fill();
        }

        isDrawing = false;
        lastPoint = null;
        addStroke(currentStroke);
        channel?.send({
          type: "broadcast",
          event: "student_stroke_end",
          payload: {
            username,
            stroke: {
              id: currentStroke.id,
              color: currentStroke.color,
              size: currentStroke.size,
              points: currentStroke.points,
            },
          },
        });
        currentStroke = null;
      });

      canvas.addEventListener("pointerleave", () => {
        if (!loginForm.classList.contains("hidden")) return;
        if (isErasing) {
          isErasing = false;
          lastPoint = null;
          if (erasedStrokes.length > 0) {
            updateHistoryButtons();
          }
          return;
        }
        if (!isDrawing) return;
        isDrawing = false;
        lastPoint = null;
        currentStroke = null;
      });

      function deleteStrokesInPath(x, y) {
        const eraserRadius = Math.max(30, brushSize * 3);
        const deletedThisFrame = new Set();
        const currentlyDeletedIds = new Set();
        for (let i = 0; i <= historyStep; i++) {
          const action = strokes[i];
          if (action?.type === "erase") {
            action.deletedIds.forEach((id) => currentlyDeletedIds.add(id));
          }
        }
        for (let i = historyStep; i >= 0; i--) {
          const stroke = strokes[i];
          if (!stroke || stroke.isTeacher || stroke.type === "erase") continue;
          if (currentlyDeletedIds.has(stroke.id)) continue;
          if (erasedStrokes.find((e) => e.id === stroke.id)) continue;
          let shouldDelete = false;
          for (let j = 0; j < stroke.points.length; j++) {
            const point = stroke.points[j];
            const dist = Math.hypot(point.x - x, point.y - y);
            if (dist < eraserRadius + (stroke.size || 3) / 2) {
              shouldDelete = true;
              break;
            }
            if (j > 0) {
              const prevPoint = stroke.points[j - 1];
              const lineDistSq = distToSegmentSquared(
                x,
                y,
                prevPoint.x,
                prevPoint.y,
                point.x,
                point.y,
              );
              if (lineDistSq < (eraserRadius + (stroke.size || 3) / 2) ** 2) {
                shouldDelete = true;
                break;
              }
            }
          }
          if (shouldDelete) {
            deletedThisFrame.add(stroke.id);
            erasedStrokes.push(stroke);
            channel?.send({
              type: "broadcast",
              event: "student_stroke_delete",
              payload: { username, strokeId: stroke.id },
            });
          }
        }
        if (deletedThisFrame.size > 0) {
          redrawCanvas();
        }
      }

      function distToSegmentSquared(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSq = dx * dx + dy * dy;
        if (lengthSq === 0) return (px - x1) ** 2 + (py - y1) ** 2;
        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
        t = Math.max(0, Math.min(1, t));
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        return (px - projX) ** 2 + (py - projY) ** 2;
      }

      redrawCanvas();
      updateHistoryButtons();

      async function login() {
        username = usernameInput.value.trim();
        sessionCode = sessionInput.value.trim().toUpperCase();
        if (!username || !sessionCode) {
          alert("Please enter your name and session code");
          return;
        }

        loginBtn.disabled = true;
        loginBtn.textContent = "Connecting‚Ä¶";
        updateStatus("connecting", "Connecting‚Ä¶");

        try {
          supabase = createClient(
            window.SUPABASE_URL,
            window.SUPABASE_ANON_KEY,
          );
          channel = supabase.channel(`minimal-${sessionCode}`, {
            config: { broadcast: { ack: false } },
          });

          channel.on(
            "broadcast",
            { event: "teacher_stroke_end" },
            ({ payload }) => {
              if (payload.target !== username) return;
              const teacherStroke = {
                id: payload.stroke.id,
                color: payload.stroke.color,
                size: payload.stroke.size,
                points: payload.stroke.points,
                isTeacher: true,
              };
              addStroke(teacherStroke);
            },
          );

          channel.on(
            "broadcast",
            { event: "teacher_state_change" },
            ({ payload }) => {
              if (payload.target !== username) return;
              payload.added.forEach((annotationData) => {
                if (!strokes.find((s) => s.id === annotationData.id)) {
                  const annotation = {
                    id: annotationData.id,
                    color: annotationData.color,
                    size: annotationData.size,
                    points: annotationData.points,
                    isTeacher: true,
                  };
                  strokes.push(annotation);
                  historyStep = strokes.length - 1;
                }
              });
              payload.removed.forEach((id) => {
                const index = strokes.findIndex(
                  (s) => s.id === id && s.isTeacher,
                );
                if (index >= 0) {
                  strokes.splice(index, 1);
                  if (historyStep >= index) {
                    historyStep = Math.max(-1, historyStep - 1);
                  }
                }
              });
              redrawCanvas();
              updateHistoryButtons();
              saveToSession();
            },
          );

          channel.on(
            "broadcast",
            { event: "teacher_stroke_delete" },
            ({ payload }) => {
              if (payload.target !== username) return;
              const index = strokes.findIndex((s) => s.id === payload.strokeId);
              if (index >= 0) {
                strokes.splice(index, 1);
                historyStep = strokes.length - 1;
                redrawCanvas();
                updateHistoryButtons();
              }
            },
          );

          channel.on("broadcast", { event: "teacher_clear" }, ({ payload }) => {
            if (payload.target !== username) return;
            strokes = strokes.filter((s) => !s.isTeacher);
            historyStep = Math.min(historyStep, strokes.length - 1);
            redrawCanvas();
            updateHistoryButtons();
          });

          channel.subscribe(async (channelStatus) => {
            if (channelStatus === "SUBSCRIBED") {
              updateStatus("connected", `Connected as ${username}`);
              await channel.send({
                type: "broadcast",
                event: "student_ready",
                payload: { username, sessionCode },
              });
              showFeedback("Connected");
            } else if (channelStatus === "CHANNEL_ERROR") {
              updateStatus("error", "Connection error");
            }
          });

          loginForm.classList.add("hidden");
          appContainer.classList.remove("hidden");
          loadFromSession();
        } catch (err) {
          console.error("Login failed", err);
          updateStatus("error", "Connection failed");
          loginBtn.disabled = false;
          loginBtn.textContent = "Join session";
          return;
        }
      }

      loginBtn.addEventListener("click", login);
      usernameInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") login();
      });
      sessionInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") login();
      });
    </script>
  </body>
</html>
